unit RobertPATmain_u;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Data.Win.ADODB, Vcl.Grids,
  Vcl.DBGrids, Vcl.ComCtrls, Vcl.StdCtrls, Vcl.ExtCtrls, Vcl.Mask,
  Vcl.Imaging.jpeg, Vcl.Buttons, Vcl.Menus, Vcl.Samples.Spin, Vcl.MPlayer,
  Vcl.AppAnalytics, Winapi.WebView2, Winapi.ActiveX, Vcl.Edge, Vcl.OleCtrls,
  SHDocVw, Vcl.ColorGrd, Vcl.BaseImageCollection, Vcl.ImageCollection,
  Vcl.WinXCalendars, Vcl.WinXCtrls, Vcl.Touch.Keyboard, Vcl.JumpList,
  Vcl.ActnMan, Vcl.ActnColorMaps, IdBaseComponent, IdComponent, IdTCPConnection,
  IdTCPClient, IdExplicitTLSClientServerBase, IdMessageClient, IdIMAP4,
  Vcl.DBCtrls, Vcl.CheckLst, Soap.InvokeRegistry, Soap.WSDLIntf,
  Soap.SOAPPasInv, Soap.SOAPHTTPPasInv,
   DateUtils, math, clsDistance_u, clsUsername_u,
  Vcl.FileCtrl, Xml.xmldom, Xml.XmlTransform, Vcl.TabNotBk,
  Vcl.WinXPickers, System.Sensors, System.Sensors.Components, Vcl.NumberBox,
  Vcl.Outline, Vcl.Samples.DirOutln, Vcl.Imaging.pngimage, printers,
  System.Notification, IdSMTPBase, IdSMTP, IdIOHandler, IdIOHandlerSocket,
  IdIOHandlerStack, IdSSL, IdSSLOpenSSL, IdMessage;

type
  TfrmVolitant_Express = class(TForm)
    conDB: TADOConnection;
    tblCompany: TADOTable;
    dsrCompany: TDataSource;
    qrySQL: TADOQuery;
    dsrSQL: TDataSource;
    tblItems: TADOTable;
    tblOrders: TADOTable;
    tblPlanes: TADOTable;
    dsrItems: TDataSource;
    dsrOrders: TDataSource;
    dsrPlanes: TDataSource;
    pgcMain: TPageControl;
    tsRegister: TTabSheet;
    tsLogin: TTabSheet;
    pgcRegister: TPageControl;
    tsDetails: TTabSheet;
    tsContact: TTabSheet;
    lblWelcome: TLabel;
    btnRegisterGO: TButton;
    btnLoginGO: TButton;
    tsLastInfo: TTabSheet;
    grbMoreInfo: TGroupBox;
    btnIntroVid: TButton;
    btnAboutUs: TButton;
    btnGallery: TButton;
    btnRegBack: TButton;
    btnLoginBack: TButton;
    lblRegister: TLabel;
    pnlCdetails: TPanel;
    lblCname: TLabel;
    edtCName: TEdit;
    lblCreatePassword: TLabel;
    edtCreatePassword: TEdit;
    lblConfirmPass: TLabel;
    edtConfirmPass: TEdit;
    chkGovernment: TCheckBox;
    imgRegPlane: TImage;
    imgBasedFlag: TImage;
    cmbCountryBased: TComboBox;
    BitBtnTOcInfo: TBitBtn;
    pnlRegContact: TPanel;
    lblRegEmail: TLabel;
    edtRegEmail: TEdit;
    chkNewsLetter: TCheckBox;
    tsRegConfirm: TTabSheet;
    pnlLastRegInfo: TPanel;
    dtpEstablishedDate: TDateTimePicker;
    lblEstabDate: TLabel;
    lblRegDefaultHours: TLabel;
    sedRegDefaultHours: TSpinEdit;
    imgRegEarth: TImage;
    BitBtnRegister: TBitBtn;
    redConfirmRegInfo: TRichEdit;
    lblConfirmReg: TLabel;
    btnRegRestart: TButton;
    tsIntroVideo: TTabSheet;
    tsGallery: TTabSheet;
    mpIntroVideo: TMediaPlayer;
    pnlVideo: TPanel;
    lblIntroVid: TLabel;
    lblGallery: TLabel;
    tsAdmin: TTabSheet;
    pgcAdmin: TPageControl;
    lblLogin: TLabel;
    tsItemsAdmin: TTabSheet;
    tsPlanesAdmin: TTabSheet;
    grbAdminQuick: TGroupBox;
    tsOrdersAdmin: TTabSheet;
    tsCompaniesAdmin: TTabSheet;
    btnToItems: TButton;
    btnToPlanes: TButton;
    btnToOrders: TButton;
    btnToCompanies: TButton;
    tsHome: TTabSheet;
    tsEmailsAdmin: TTabSheet;
    btnToEmails: TButton;
    lblUsernameLogin: TLabel;
    edtUsernameLogin: TEdit;
    edtPasswordLogin: TEdit;
    lblPasswordLogin: TLabel;
    btnLogin: TButton;
    tsCustomAdmin: TTabSheet;
    btnToSummary: TButton;
    grbHome: TGroupBox;
    tsPayment: TTabSheet;
    tsPOrder: TTabSheet;
    tsManageCompany: TTabSheet;
    tsHistory: TTabSheet;
    btnTOorder: TButton;
    btnTOhistory: TButton;
    btnTOpayment: TButton;
    btnManageCompany: TButton;
    lblGenUsername: TLabel;
    edtGUsername: TEdit;
    lblPasswordConfirm: TLabel;
    pnlConfirmPass: TPanel;
    lblConfirmAge: TLabel;
    sedCompanyAgeConfirm: TSpinEdit;
    lblConfirmOther: TLabel;
    btnPlayVid: TButton;
    btnPauseVid: TButton;
    btnRestartVid: TButton;
    BitBtnBackTOWelcomeFromVid: TBitBtn;
    imgVPLeft: TImage;
    imgVPRight: TImage;
    lblOrder: TLabel;
    lblItemsAdmin: TLabel;
    dbgSQL_admin: TDBGrid;
    edtCustomSQL: TEdit;
    lblCustomSQL: TLabel;
    btnCustomSQL: TButton;
    grbAddItem: TGroupBox;
    edtItemAddName: TEdit;
    cmbItemCategoryAdd: TComboBox;
    chkDangerousItemAdd: TCheckBox;
    redAddDescription: TRichEdit;
    lblAddItemName: TLabel;
    lblAddItemCategory: TLabel;
    btnAddCategoty: TButton;
    lblAddTransportItemPrice: TLabel;
    lblAddItemDescription: TLabel;
    btnAddItem: TButton;
    grbManageItems: TGroupBox;
    pgcOrder: TPageControl;
    tsPlaceOrder: TTabSheet;
    tsOrderSummary: TTabSheet;
    tsAdminSum: TTabSheet;
    lblAdminSum: TLabel;
    grbAddPlane: TGroupBox;
    lblManagePlanes: TLabel;
    grbManagePlanes: TGroupBox;
    lstSelectItemManage: TListBox;
    lblSelectItemTomanage: TLabel;
    btnRetireItem: TButton;
    redUpdateItem: TRichEdit;
    btnUpdateItem: TButton;
    lblUpdateItemInfo: TLabel;
    sedAddItemRands: TSpinEdit;
    sedItemAddCents: TSpinEdit;
    lblAddRands: TLabel;
    lblAddCents: TLabel;
    lblUpdateItemPrice: TLabel;
    sedUpdateItemRands: TSpinEdit;
    sedUpdateItemCents: TSpinEdit;
    lblUpdateItemRands: TLabel;
    lblUpdateItemCents: TLabel;
    edtAddPlaneName: TEdit;
    sedAddPlaneMLoad: TSpinEdit;
    sedAddPlaneCSpeed: TSpinEdit;
    sedAddFuelRands: TSpinEdit;
    sedAddFuelCents: TSpinEdit;
    sedAddPlaneMDistance: TSpinEdit;
    btnAddPlane: TButton;
    lblAddNameOfPlane: TLabel;
    lblAddPlaneMaxLoad: TLabel;
    lblAddPlaneCruiseSpeed: TLabel;
    lblAddPlaneDistance: TLabel;
    lblPlaneAddFeulCosr: TLabel;
    lblAddFuelRand: TLabel;
    lblAddFuelCents: TLabel;
    lblUpdateFuelPrice: TLabel;
    chkRetirePlane: TCheckBox;
    sedUpdateFuelRands: TSpinEdit;
    sedUpdateFuelCents: TSpinEdit;
    lblUpdateFuelRands: TLabel;
    lblUpdateFuelCents: TLabel;
    lstManagePlane: TListBox;
    lblSelectPlaneUpdate: TLabel;
    btnUpdatePlane: TButton;
    cmbSelectTable: TComboBox;
    dbgDifferentTables: TDBGrid;
    grbSelectTable: TGroupBox;
    grbTableTotal: TGroupBox;
    pnlTotalAccounts: TPanel;
    pnlTotalOrders: TPanel;
    pnlTotalItems: TPanel;
    pnlTotalPlanes: TPanel;
    btnReloadSum: TButton;
    grbStatistics: TGroupBox;
    lblTopPlain: TLabel;
    lblTopItem: TLabel;
    lblTotalRevenue: TLabel;
    lblTopPickupC: TLabel;
    lblTopDropOffC: TLabel;
    lblAverageWeight: TLabel;
    grbProgress: TGroupBox;
    PBrevenue: TProgressBar;
    PBOrders: TProgressBar;
    lblRevenueProgress: TLabel;
    lblOrdersManagedProgress: TLabel;
    lblCustomSQLPage: TLabel;
    sbGallery: TScrollBox;
    btnToCustom: TButton;
    chkConfirmRegInfo: TCheckBox;
    tsWelcome: TTabSheet;
    imgLogo_2: TImage;
    imgLogo_1: TImage;
    lblAdminOrders: TLabel;
    grpUpdateOrder: TGroupBox;
    lstSelectOrderAdmin: TListBox;
    pgcAdminOrders: TPageControl;
    tsOrderUpdate: TTabSheet;
    tsOrderOutput: TTabSheet;
    redOrderOut: TRichEdit;
    btnOrderSumAdmin: TButton;
    btnOrdersOutstandingPayment: TButton;
    btnOrderPhaseAdmin: TButton;
    cmbOrderPhaseSearch: TComboBox;
    edtCompanyNameSearchOrders: TEdit;
    lblCompanyNameToSearch: TLabel;
    btnSearchForOrders: TButton;
    BitBtnClearOrderSearch: TBitBtn;
    lblSelectOrderStatus: TLabel;
    rgpOrderStatus: TRadioGroup;
    btnUpdateOrderStatus: TButton;
    lblManageCompanies: TLabel;
    btnToOrdersOutput: TButton;
    btnTOorderUpdate: TButton;
    redCompanyOut: TRichEdit;
    btnCompanyOrderOut: TButton;
    btnSeatchForCompany: TButton;
    btnSearcCompAgeRange: TButton;
    edtEnterSearchCompany: TEdit;
    sedAgeBottomSearch: TSpinEdit;
    sedAgeTopSearch: TSpinEdit;
    lblSearchForComanyAge: TLabel;
    lblAgeBottom: TLabel;
    lblTopAge: TLabel;
    lblSendEmails: TLabel;
    grbNewsLetter: TGroupBox;
    memNewsLetterMessage: TMemo;
    btnSendNewsletter: TButton;
    lblWelcomeHome: TLabel;
    btnCInfoBack: TButton;
    btnLastInfoBack: TButton;
    bitbtnCloseProgram: TBitBtn;
    btnBackFromGallery: TButton;
    bitbtnRegHelp: TBitBtn;
    bitbtnLoginHelp: TBitBtn;
    bitbtnAdminHelp: TBitBtn;
    bitBtnHomeHelp: TBitBtn;
    lblPayment: TLabel;
    lstPayment: TListBox;
    lblSelectOrderToPay: TLabel;
    BitBtnPay: TBitBtn;
    redPaymentConfirm: TRichEdit;
    btnBackHomeFromPay: TButton;
    BitBtnPaymentHelp: TBitBtn;
    BitBtnretryPaySelect: TBitBtn;
    BitBtnNextToLastInfo: TBitBtn;
    BitBtnNextToConfirm: TBitBtn;
    pnlFlightAnimation: TPanel;
    imgPlaneAnimation: TImage;
    tFlightAnimation: TTimer;
    lblSelectCountry: TLabel;
    lblGalleryInfo: TLabel;
    lblConfirmYears: TLabel;
    tsThemeAdmin: TTabSheet;
    btnToTheme: TButton;
    edtSearchForItem: TEdit;
    chkChangeItemDangerous: TCheckBox;
    lblThemePage: TLabel;
    grbUpdateFormTheme: TGroupBox;
    ColorDialogFORM: TColorDialog;
    btnChangeFORMtheme: TButton;
    btnFormThemeDefault: TButton;
    grpChangeHomeTheme: TGroupBox;
    CGhomeTheme: TColorGrid;
    lblColorGridInfo: TLabel;
    lblHomeThemeInfo: TLabel;
    btnHomeThemeDefault: TButton;
    grbUpdateWelcomeLabel: TGroupBox;
    clbWelcomeLabelTheme: TColorListBox;
    btnUpdateWelcomeLabel: TButton;
    sedEnterCompanyID: TSpinEdit;
    btnLoadCompany: TButton;
    sedEnterCNameSearchOrderUpdate: TSpinEdit;
    lblEnterCompanyID: TLabel;
    btnDeleteCompanyAdmin: TButton;
    chkSuspendAccount: TCheckBox;
    btnUpdateSuspension: TButton;
    tsGrid: TTabSheet;
    btnToGrid: TButton;
    lblSortDatabase: TLabel;
    dbgGridDisplay: TDBGrid;
    qryGrid: TADOQuery;
    dsrGrid: TDataSource;
    grbGrid: TGroupBox;
    btnItemOrderPrice: TButton;
    btnToAdminManage: TButton;
    tsAdminManage: TTabSheet;
    lblManageAdmin: TLabel;
    lblAdminSelectOrderInfo: TLabel;
    grbUpdatePickupDate: TGroupBox;
    tpUpdatePickupTime: TTimePicker;
    lblUpdatePickupDate: TLabel;
    lblUpdatePickupTime: TLabel;
    dpUpdatePickupDate: TDatePicker;
    btnOrderToSummary: TButton;
    BitBtnPlaceOrder: TBitBtn;
    BitBtnBackToPlaceOrderPage: TBitBtn;
    BitBtnBackHomeFromOrders: TBitBtn;
    lblManageCompany: TLabel;
    BitBtnUpdateCompanyInfo: TBitBtn;
    BitBtnToHomeFromManageCompany: TBitBtn;
    grbManageCompany: TGroupBox;
    lblUpdateCompanyName: TLabel;
    lblUpdatePassword: TLabel;
    lblUpdatePasswordConfirm: TLabel;
    lblUpdateEmail: TLabel;
    lblUpdateCountryBased: TLabel;
    lblUpdateDefaultHours: TLabel;
    edtUpdateCompanyName: TEdit;
    edtUpdatePassword: TEdit;
    edtConfirmUpdatedPassword: TEdit;
    edtUpdateEmail: TEdit;
    cmbUpdateCountryBased: TComboBox;
    sedUpdateDefaultHours: TSpinEdit;
    chkUpdateGovernment: TCheckBox;
    chkUpdateNewsletter: TCheckBox;
    imgUpdateCountryBased: TImage;
    Button1: TButton;
    lblSearchOrderByCID: TLabel;
    lblEnterOrderDetails: TLabel;
    grbSelectOrderCountries: TGroupBox;
    lblSelectPickupCountry: TLabel;
    lblSelectDropOfCountry: TLabel;
    cmbSelectPickupCountry: TComboBox;
    cmbSelectDropOffCountry: TComboBox;
    grbChooseItems: TGroupBox;
    lblChooseItem: TLabel;
    sedAddOrderKg: TSpinEdit;
    sedOrderGrams: TSpinEdit;
    lblAddOrderKg: TLabel;
    lblOrderAddGram: TLabel;
    lstSelectTransportItem: TListBox;
    cmbCategory: TComboBox;
    lblSelectCategory: TLabel;
    grbChoosePickupTime: TGroupBox;
    dtpChoosePickupDate: TDateTimePicker;
    tpChoosePickupTime: TTimePicker;
    lblChoosePickupDate: TLabel;
    lblChoosePickupTime: TLabel;
    grbChooseOrderWeight: TGroupBox;
    imgPickupCountry: TImage;
    imgDropOffCountry: TImage;
    lblFromTransportCountries: TLabel;
    tblAdmins: TADOTable;
    dsrAdmins: TDataSource;
    chkLoginAsAdmin: TCheckBox;
    redOrderSummary: TRichEdit;
    pdPrint: TPrintDialog;
    BitBtnPrintOrderSlip: TBitBtn;
    chkUserDeleteAcoount: TCheckBox;
    BitBtnManageCompanyHelp: TBitBtn;
    lblAdmin: TLabel;
    grbLoginTheme: TGroupBox;
    clbLoginLabel: TColorListBox;
    btnUpdateLoginLabelTheme: TButton;
    grbUpdateORdersLabelTheme: TGroupBox;
    clbUpdateOrdersLabelTheme: TColorListBox;
    btnUpdateOrderLabelTheme: TButton;
    dbgAdmins: TDBGrid;
    grbSelectAdminPermissions: TGroupBox;
    lblSelectAdminAccount: TLabel;
    grbAdminAccountManage: TGroupBox;
    chkAdminChangeTheme: TCheckBox;
    chkAdminDeveloper: TCheckBox;
    chkAdminManageAdmins: TCheckBox;
    chkAdminNewsletter: TCheckBox;
    chkAdminManagePlanes: TCheckBox;
    chkAdminItemManage: TCheckBox;
    BitBtUpdateADmin: TBitBtn;
    lblAdminUsername: TLabel;
    lblAdminPassword: TLabel;
    edtAdminUsername: TEdit;
    edtAdminPassword: TEdit;
    chkAddAdminAccount: TCheckBox;
    btnGroupOrdersByStatus: TButton;
    Button2: TButton;
    btnSortCompanyTable: TButton;
    btnTopPickupC: TButton;
    btnPopularDropOffCounries: TButton;
    btnAverageFuelCost: TButton;
    btnRetiredItemsCount: TButton;
    bttCompaniesUnpaidOrders: TButton;
    lblSearchByOrderID: TLabel;
    sedSearchByOrderID: TSpinEdit;
    IdSMTP1: TIdSMTP;
    IdMessage1: TIdMessage;
    IdSSLIOHandlerSocketOpenSSL1: TIdSSLIOHandlerSocketOpenSSL;
    procedure FormActivate(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure btnRegisterGOClick(Sender: TObject);
    procedure btnLoginGOClick(Sender: TObject);
    procedure btnIntroVidClick(Sender: TObject);
    procedure btnAboutUsClick(Sender: TObject);
    procedure btnGalleryClick(Sender: TObject);
    procedure btnRegBackClick(Sender: TObject);
    procedure btnLoginBackClick(Sender: TObject);
    procedure BitBtnTOcInfoClick(Sender: TObject);
    procedure cmbCountryBasedChange(Sender: TObject);
    procedure BitBtnRegisterClick(Sender: TObject);
    procedure btnRegRestartClick(Sender: TObject);
    procedure btnLoginClick(Sender: TObject);
    procedure btnTOorderClick(Sender: TObject);
    procedure btnPlayVidClick(Sender: TObject);
    procedure btnPauseVidClick(Sender: TObject);
    procedure btnRestartVidClick(Sender: TObject);
    procedure BitBtnBackTOWelcomeFromVidClick(Sender: TObject);
    procedure btnCustomSQLClick(Sender: TObject);
    procedure btnAddCategotyClick(Sender: TObject);
    procedure btnAddItemClick(Sender: TObject);
    procedure btnRetireItemClick(Sender: TObject);
    procedure lstSelectItemManageClick(Sender: TObject);
    procedure btnUpdateItemClick(Sender: TObject);
    procedure btnUpdatePlaneClick(Sender: TObject);
    procedure dbgDifferentTablesCellClick(Column: TColumn);
    procedure btnReloadSumClick(Sender: TObject);
    procedure cmbSelectTableChange(Sender: TObject);
    procedure btnToCustomClick(Sender: TObject);
    procedure btnOrderPhaseAdminClick(Sender: TObject);
    procedure btnToOrdersOutputClick(Sender: TObject);
    procedure btnTOorderUpdateClick(Sender: TObject);
    procedure btnCompanyOrderOutClick(Sender: TObject);
    procedure btnSendNewsletterClick(Sender: TObject);
    procedure btnTOhistoryClick(Sender: TObject);
    procedure btnTOpaymentClick(Sender: TObject);
    procedure btnManageCompanyClick(Sender: TObject);
    procedure bitbtnCloseProgramClick(Sender: TObject);
    procedure btnBackFromGalleryClick(Sender: TObject);
    procedure BitBtnNextToConfirmClick(Sender: TObject);
    procedure btnCInfoBackClick(Sender: TObject);
    procedure BitBtnNextToLastInfoClick(Sender: TObject);
    procedure btnLastInfoBackClick(Sender: TObject);
    procedure tFlightAnimationTimer(Sender: TObject);
    procedure btnToSummaryClick(Sender: TObject);
    procedure btnToEmailsClick(Sender: TObject);
    procedure btnToItemsClick(Sender: TObject);
    procedure btnToThemeClick(Sender: TObject);
    procedure edtSearchForItemChange(Sender: TObject);
    procedure btnAddPlaneClick(Sender: TObject);
    procedure btnChangeFORMthemeClick(Sender: TObject);
    procedure btnFormThemeDefaultClick(Sender: TObject);
    Procedure imgDynamicOnclick(Sender: TObject);
    procedure btnUpdateWelcomeLabelClick(Sender: TObject);
    procedure btnSearcCompAgeRangeClick(Sender: TObject);
    procedure btnSeatchForCompanyClick(Sender: TObject);
    procedure btnLoadCompanyClick(Sender: TObject);
    procedure BitBtnretryPaySelectClick(Sender: TObject);
    procedure sedEnterCompanyIDChange(Sender: TObject);
    procedure pgcAdminChange(Sender: TObject);
    procedure btnDeleteCompanyAdminClick(Sender: TObject);
    procedure btnUpdateSuspensionClick(Sender: TObject);
    procedure btnToPlanesClick(Sender: TObject);
    procedure lstManagePlaneClick(Sender: TObject);
    procedure btnUpdateOrderStatusClick(Sender: TObject);
    procedure btnSearchForOrdersClick(Sender: TObject);
    procedure btnItemOrderPriceClick(Sender: TObject);
    procedure btnOrderSumAdminClick(Sender: TObject);
    procedure btnHomeThemeDefaultClick(Sender: TObject);
    procedure CGhomeThemeClick(Sender: TObject);
    procedure btnOrdersOutstandingPaymentClick(Sender: TObject);
    procedure btnToOrdersClick(Sender: TObject);
    procedure BitBtnClearOrderSearchClick(Sender: TObject);
    procedure edtCompanyNameSearchOrdersClick(Sender: TObject);
    procedure sedEnterCNameSearchOrderUpdateChange(Sender: TObject);
    procedure lstSelectOrderAdminClick(Sender: TObject);
    procedure rgpOrderStatusClick(Sender: TObject);
    procedure btnOrderToSummaryClick(Sender: TObject);
    procedure BitBtnPlaceOrderClick(Sender: TObject);
    procedure BitBtnBackToPlaceOrderPageClick(Sender: TObject);
    procedure BitBtnBackHomeFromOrdersClick(Sender: TObject);
    procedure BitBtnToHomeFromManageCompanyClick(Sender: TObject);
    procedure BitBtnUpdateCompanyInfoClick(Sender: TObject);
    procedure cmbUpdateCountryBasedChange(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure lstSelectTransportItemClick(Sender: TObject);
    procedure cmbCategoryChange(Sender: TObject);
    procedure cmbSelectPickupCountryChange(Sender: TObject);
    procedure cmbSelectDropOffCountryChange(Sender: TObject);
    procedure lstPaymentClick(Sender: TObject);
    procedure BitBtnPayClick(Sender: TObject);
    procedure btnBackHomeFromPayClick(Sender: TObject);
    procedure btnToGridClick(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure BitBtnPrintOrderSlipClick(Sender: TObject);
    procedure chkUserDeleteAcoountClick(Sender: TObject);
    procedure btnLoginMouseEnter(Sender: TObject);
    procedure btnLoginMouseLeave(Sender: TObject);
    procedure btnUpdateLoginLabelThemeClick(Sender: TObject);
    procedure btnUpdateOrderLabelThemeClick(Sender: TObject);
    procedure btnToCompaniesClick(Sender: TObject);
    procedure btnToAdminManageClick(Sender: TObject);
    procedure BitBtUpdateADminClick(Sender: TObject);
    procedure chkAddAdminAccountClick(Sender: TObject);
    procedure dbgAdminsCellClick(Column: TColumn);
    procedure btnGroupOrdersByStatusClick(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure btnSortCompanyTableClick(Sender: TObject);
    procedure btnTopPickupCClick(Sender: TObject);
    procedure btnPopularDropOffCounriesClick(Sender: TObject);
    procedure btnAverageFuelCostClick(Sender: TObject);
    procedure btnRetiredItemsCountClick(Sender: TObject);
    procedure bttCompaniesUnpaidOrdersClick(Sender: TObject);
    procedure sedSearchByOrderIDChange(Sender: TObject);
  private
    { Private declarations }

    // Class declaration
    objDistance : TDistance ;
    objUsername : TUsername ;
    //Functions
    Function ValidateEmail(pEmail: string): Boolean;
    Function DeleteAccount(pID : integer): boolean;
    Function CalcOrderPrice(pOrderID: integer) : real;
    Function GetPlainCruisingSpeed(pPlaneID : integer) : real;
    Function CalcBaseCost(pGovernment: boolean; pEstablishmentDate : TDate) : real ;
    Function FindPlane(pOrderWeight, pDistance: real; pPickupDateTime : TDateTime) : integer;
    Function Prevent_Duplication(): string;
    // Procedures
    Procedure WriteToFormTheme(pFileName : string; pColorValue : integer); // For writing to the files for system themes
    Procedure SetOrderStatusItemIndex(pStatus : string);
    Procedure SendEmail(pEmailAddress, pMessage: string) ;

  public
    { Public declarations }
  // Array declaration
    arrCountryName,  arrCountryCode : array[1..245] of string;
    arrLatitude, arrLongitude : array[1..245] of real ;
    arrSpecialCharacters : array[1..32] of char;

  // Variable declararion
    iID : integer ;
    iCountryCount,  iSpecialCharacterCount : integer ;
    bTimer : boolean;

      // For the gallery
     iImageCount : integer;
    arrFileNames : array[1..1000] of string;

    // ItemUpdate ID
    iItemUpdateID : integer ;

  end;

var
  frmVolitant_Express: TfrmVolitant_Express;
  imgDynamicGallery : TImage ;

implementation

{$R *.dfm}

procedure TfrmVolitant_Express.BitBtnClearOrderSearchClick(Sender: TObject);
begin
// Clear the inputs for earching for a Company using their name or ID
edtCompanyNameSearchOrders.Clear;
sedEnterCNameSearchOrderUpdate.Value := 0 ;
sedSearchByOrderID.Value := 0 ;
end;

procedure TfrmVolitant_Express.bitbtnCloseProgramClick(Sender: TObject);
begin
// Closes/ ends the program
end;

procedure TfrmVolitant_Express.BitBtnBackHomeFromOrdersClick(Sender: TObject);
begin
// Go back to the home page from the place an order page
tsPOrder.TabVisible := False ;
tsHome.TabVisible := True ;
end;

procedure TfrmVolitant_Express.BitBtnBackToPlaceOrderPageClick(Sender: TObject);
begin
// Go back to the place an order page
tsOrderSummary.TabVisible := False ;
tsPlaceOrder.TabVisible := true;
end;

procedure TfrmVolitant_Express.BitBtnBackTOWelcomeFromVidClick(Sender: TObject);
begin
// Go back to the welcome page from the watch video page
mpIntroVideo.Stop;     // Stop the video

// Change pages
tsIntroVideo.TabVisible := false;
tsWelcome.TabVisible:= True ;
end;

procedure TfrmVolitant_Express.BitBtnNextToConfirmClick(Sender: TObject);
var
  bUsernameFound : boolean;
  sUsernameCreated : string;
begin
    // go to the reg confirmation page from the last info page
      redConfirmRegInfo.Clear ;
      // Validation
     // Check to make sure that the date of the companies establishment is in the past and NOT in the furure
     if dtpEstablishedDate.Date > date then
     begin
       ShowMessage('Invalid date of establishment') ;
      Exit;
     end;
     // Fill the fields on the registration page
     pnlConfirmPass.Caption := 'You Password: ' + edtCreatePassword.Text ;
     sedCompanyAgeConfirm.Value := YearsBetween(date, dtpEstablishedDate.Date) ;
    // Richedit
     //Government agency
     if chkGovernment.Checked then
     redConfirmRegInfo.Lines.Add('Government Agency: YES')
     else
      redConfirmRegInfo.Lines.Add('Government Agency: NO') ;
   //Country based
    redConfirmRegInfo.Lines.Add('Country Based: '+ cmbCountryBased.Items[cmbCountryBased.ItemIndex]);
    // Email
     redConfirmRegInfo.Lines.Add('Email: '+ edtRegEmail.Text) ;
     // NEwsletter
     if chkNewsLetter.Checked then
      redConfirmRegInfo.Lines.Add('Newsletter: YES' )
      else
       redConfirmRegInfo.Lines.Add('Newsletter: NO');
      // Defualt hours
       redConfirmRegInfo.Lines.Add('Defualt Hours: ' + IntToStr(sedRegDefaultHours.Value) );

     tsLastInfo.TabVisible := False ;
     tsRegConfirm.TabVisible := True;

    // initialise the username class
    objUsername := TUsername.Create(edtCName.Text , cmbCountryBased.Items[cmbCountrybased.ItemIndex],dtpEstablishedDate.Date );

    sUsernameCreated := objUsername.ToString ; // Call the ToString Function
    edtGUsername.Text := sUsernameCreated ;
    
    // Check to make sure that the username does not exist. (IT can be possible, as you cant register a company twice, however, a company starting with the same word can technically generate twice )
    repeat
      bUsernameFound := False;
      tblCompany.First ;
      while not tblCompany.eof do
      begin
        if tblCompany['Username'] = sUsernameCreated then // Check for a duplicate username
        begin
          sUsernameCreated := Copy(sUsernameCreated ,1, Pos('_', sUsernameCreated) ); // Just keep everything beforee the uudnerscore
          bUsernameFound := True; // Change to true as the username has been found
          sUsernameCreated := sUsernameCreated + IntToStr(RandomRange(1, 1000) ) ;   // Generate a new random number for after the undersocre

            objUsername.SetUsername(sUsernameCreated) ; // Update the username to the object
            break; // exit the loop to save time
        end;
        tblCompany.Next ;
      end;
      
    until bUsernameFound = False; // If no duplicate username was found, then no need to check again
  chkConfirmRegInfo.Checked := False;
end;

procedure TfrmVolitant_Express.BitBtnNextToLastInfoClick(Sender: TObject);
var
  sEmail : string ; 
  I, iPointPos, iATcount : integer ;
  bPoint: boolean;
begin
// Go to the Last info reg page from the contact details reg page
    sEmail := edtRegEmail.Text ;
  // Validation
 if not  ValidateEmail(sEmail) then // if the email was not correct then exit the program
 exit;

 tsContact.TabVisible := False ;
 tsLastInfo.TabVisible := True ;

end;

procedure TfrmVolitant_Express.BitBtnPayClick(Sender: TObject);
var
  sLine, sCardNumber, sPaymentConfirmation : string ;
  iOrderID : integer;
  bOrderFound : boolean;
  I: Integer;
begin
// Pay the order
  redPaymentConfirm.Clear ;
  //Validation
    // Ensure that a valid order to pay is selected
    if lstPayment.ItemIndex = -1 then
    begin
      ShowMessage('Please Select a valid Order to pay') ;
      exit ;
    end;
        // Ask for the card number (Concept)
        /// Generate a card number for the concept
        sCardNumber := '';
        for I := 1 to 4 do
        begin
          sCardNumber := sCardNumber + IntToStr(RandomRange(0, 10000) )  ;
        end;
        // If the card number is shorter than 16 characters, add 0's at the front
        while Length(sCardNumber) < 16  do
        Insert('0', sCardNumber,1);
        // receive the card number to make the payment
      sCardNumber := InputBox('Enter your Company Bank account number to Pay for your order', 'Add no spaces please',  sCardNumber ) ;
      // Validate that the entered card number is shorter than 16 characters
      if not (Length(sCardNumber) = 16)  then
      begin
        ShowMessage('Invalid Card Number. Enter a valid card number') ;
        exit ;
      end;
      // Validate that all of the entered card numbers is valid, by checking that it only contains numbers
      for I := 1 to 16 do
      begin
        if not (sCardNumber[i] in ['0'..'9']) then
        begin
          ShowMessage('Invalid card number entered. Enter a valid card number to proceed with payment') ;
          exit;
        end;
      end;
    // get the order ID
    slIne := lstPayment.Items[lstPayment.ItemIndex] ;
    Delete(sLine, 1, Pos(':', sLine) ) ;
    iOrderID := StrToInt(Copy(sLine, 1 ,Pos(' --Item:', sLIne)-1) )   ;
      // Search for the ID
      tblOrders.First ;
      bOrderFound := false;
      while not tblOrders.Eof and (bOrderFound = False) do
      begin
        if tblOrders['OrderID'] = iOrderID then  // If a matching ID is found
        begin
          bOrderFound := True ;

            if MessageDlg('Confirm that you would like to pay your transport fee for order number: ' + IntToStr(iOrderID) , TMsgDlgType.mtConfirmation, [mbYes, mbNo], 0) = mrYes  then
            begin
              tblOrders.Edit ;
              tblOrders['Paid'] := true ;
              tblOrders.Post ;
              // Remove paid order from lst box
              lstPayment.Items.Delete(lstPayment.ItemIndex) ;
                // give paid order confirmation in the rich edit
                sPaymentConfirmation := 'Payment Confirmation:' + #13+ 'OrderID: ' + IntToStr(iorderID) +#13+ 'Total order price: ' + FloatToStrF(CalcOrderPrice(iOrderID), ffCurrency , 10,2 ) + #13+ 'Order Paid SUCCESSFULLY' ;
                redPaymentConfirm.Lines.Add(sPaymentConfirmation)  ;
                // Send email pop
                  // Get email addres
                  qrySQL.SQL.Text := 'Select Email from tblCompany where CompanyID =' + IntToStr(iID)  ;
                   qrySQL.Open ;
                  SendEmail(qrySQL['Email'], sPaymentConfirmation) ;
              ShowMessage('Transportation payment made successfully for order '+ IntToStr(iOrderID) );
            end
            else
            ShowMessage('Transport payment cancelled.') ;
        end;
        tblOrders.Next ;
      end;
end;

procedure TfrmVolitant_Express.BitBtnPlaceOrderClick(Sender: TObject);
begin
// Place an order

   if MessageDlg('I hereby confirm that my order is correct and ready to be submitted' , TMsgDlgType.mtConfirmation, [mbYes, mbNo], 0) = mrYes  then
   begin  // If user confirms



    // Add order ID to the richedit after appending to the database

            // Write to History log the prices of the order at that time

      // Add some sort of a method that prevents the order slip from being easily duplicated
       redOrderSummary.Lines.Add(#13+#13+Prevent_Duplication );
        // Enable print button
        BitBtnPrintOrderSlip.Enabled := True ;
        // After order is completed, clear the input fields on order placement page


        // Disable Place order button

        // Go to the pay for order page and select the new order to be paid
          // Ask if user wants to go to the payment page
          // Make a button visible to go to the payment page
   end
   else
   begin // If the now button is pressed
    ShowMessage('The Order has not been placed');
   end;
end;

procedure TfrmVolitant_Express.BitBtnPrintOrderSlipClick(Sender: TObject);
begin
  // Print the Orders slip
  if pdPrint.Execute  then
        begin
            redOrderSummary.Print('Order Slip');
        end;
end;

procedure TfrmVolitant_Express.BitBtnRegisterClick(Sender: TObject);
var
  sCName, sCRegPassword, sUsernameGenerated, sRegEmail, sLocationBasedReg: string;
  bGovernment, bNewsLetter : boolean;
  dDateEnstablished, dRegDate : tDate;
  iDefaultHours : integer ;
begin
// register the company

  //Confirmation
  if chkConfirmRegInfo.Checked = false then
  begin
    ShowMessage('You need to confirm that the provided info is true!');
    Exit;
  end;


  // Read values into variables
  sCName := edtCName.Text ;
  sCRegPassword := edtCreatePassword.Text ;
  sUsernameGenerated := objUsername.GetUsername ;
  sRegEmail := edtRegEmail.Text ;

   //Government agency
     if chkGovernment.Checked then
      bGovernment := True
     else
      bGovernment := false;

   dDateEnstablished := dtpEstablishedDate.Date;
   sLocationBasedReg := cmbCountryBased.Items[cmbCountryBased.ItemIndex];
    // NEwsletter
     if chkNewsLetter.Checked then
    bNewsLetter := true
      else
    bNewsLetter := False;

    dRegDate := Date;
    iDefaultHours := sedRegDefaultHours.Value ;

// Write to the db

  tblCompany.Insert ;

  tblCompany['CompanyName']:= sCName;
  tblCompany['Password'] := sCRegPassword ;
  tblCompany['Username']:= sUsernameGenerated ;
  tblCompany['Email']:= sRegEmail ;
  tblCompany['Goverment Agency']:= bGovernment ;
  tblCompany['RegDate'] := dRegDate ;
  tblCompany['Location Based'] := sLocationBasedReg ;
  tblCompany['Newsletter'] := bNewsLetter ;
  tblCompany['Establishment Date'] := dDateEnstablished ;
  tblCompany['Defualt Hours'] := iDefaultHours ;

  tblCompany.Post ;

// Go to the Home page
tsRegister.TabVisible := false;
tsHome.TabVisible := True ;
end;

procedure TfrmVolitant_Express.BitBtnretryPaySelectClick(Sender: TObject);
begin
// Reset the pay order list box
lstPayment.ItemIndex := -1;
end;

procedure TfrmVolitant_Express.BitBtnTOcInfoClick(Sender: TObject);
var
  sName, sPassword: string ;
  I: Integer;
  cChar, c : char;
  bErrorCharacter, bNumber, bCapital, bSpecialCharacter : boolean ;
begin
// Go to the next page of register; the Contact Info page

    sName := edtCName.Text ;
    sPassword := edtCreatePassword.Text ;
   // Validation

   // Company Name
   if (sName = '') or (sName = ' ') then
   begin
     ShowMessage('Please enter your Company Name') ;
     Exit;
   end;
   // Range Check
   if not ((Length(sName) >=1) and (Length(sName) <= 30 )) then
   begin
     ShowMessage('Company Name Length should be between 1 and 30 characters');
     Exit;
   end;
   // Last character may not be a space
   if sName[Length(sName) ] = ' ' then
   begin
     ShowMessage('The last character of the name may not be a space');
     exit; 
   end;
    // Check that the Company Name does not contain any elegal characters
   for I := 1 to Length(sName)  do
    begin
      if not ((sName[i] in ['A'..'Z']) or (sName[i] in ['a'..'z']) or (sName[i] in ['$', '-', ',', '.', '''', ' ']) or (sName[i] in ['0'..'9'])) then
      begin
        ShowMessage('Only alphabet characters, spaces and these special characters are allowed in the Name: '+ #13+ '$ - , . ''');
        Exit;
      end;
      
    end;

    // Check that the Company Name does not already exist (Check that the company has not been registered )
    tblCompany.first;
    while not tblCompany.Eof do
    begin
      if UpperCase(sName) = Uppercase(tblCompany['CompanyName'])  then
      begin
        ShowMessage('Company Already Registered.');
        Exit; 
      end;
    
      tblCompany.Next ;
    end;    

    // CountryBased. Make sure that a country was entered
    if cmbCountryBased.ItemIndex = -1 then
    begin
      ShowMessage('Please Select/Enter a valid Country');
      Exit; 
    end;
    
   // Password

   bNumber := False;
   bCapital := false;
   bSpecialCharacter := False;
   
   // Check that the password is in range
    if not ((Length(sPassword) >= 6) and (Length(sPassword) <= 20 )) then
    begin
      ShowMessage('Password Should be between 6 and 20 character long.');
      exit;
    end;
    // Check that the password is a valid passowrd
    for cChar  in sPassword  do
    begin

       bErrorCharacter := true;
      for c in arrSpecialCharacters do    // Checks that all the characters are valid
      begin
          if  (cChar = c) or (cChar in ['A'..'Z']) or (cChar in ['a'..'z']) or (cChar in ['0'..'9']) then
          begin
          bErrorCharacter := False ;
        //  break;     // exit the loop but not the procedure. Performance
          end

      end;

      if bErrorCharacter = true then
      begin
        ShowMessage('Invalid/Unsupported character in Password'+#13+'(Spaces are not allowed)')  ;
        exit;
      end ;

      // Check that password is secure
      if cChar in ['0'..'9'] then
      bNumber := True ;

      if cChar in ['A'..'Z'] then
       bCapital := True;

        if bSpecialCharacter = false then
        begin
            for c in arrSpecialCharacters  do
            begin
               if cChar = c then
               begin
               bSpecialCharacter := true ;
           //    break ;   // exit the loop but not the procedure.Performance
               end;
            end;
        end;
    end;
    // Password secure dialogue
    if not (bNumber = true and bCapital = true and bSpecialCharacter = true) then
    begin
      ShowMessage('Password does not meet the requirement.'+#13+'Password should contain atleast 1:'+#13+'-Special character'+#13+'-Capital Letter'+#13+'-Number');
      exit;
    end;
    // Make sure that you have entered the password that you think you have
    if not (sPassword = edtConfirmPass.Text ) then
    begin
      ShowMessage('Password do not match' )  ;
      exit;
    end;

   tsDetails.TabVisible := False;
   tsContact.TabVisible := True ;   
end;

procedure TfrmVolitant_Express.BitBtnToHomeFromManageCompanyClick(
  Sender: TObject);
begin
// Go to the Home page from the manage company page
tsManageCompany.TabVisible := False ;
tsHome.TabVisible := True ;
end;

procedure TfrmVolitant_Express.BitBtnUpdateCompanyInfoClick(Sender: TObject);
var
  sName, sPassword, sEmail: string ;
  I, iRandom: Integer;
  cChar, c : char;
  bErrorCharacter, bNumber, bCapital, bSpecialCharacter : boolean ;
begin
// Update the Company details
  if chkUserDeleteAcoount.Checked  then
  begin // Check if the User has selected to detete their account
      // Ask for confirmation
    iRandom := RandomRange(100, 1000);
    if Inputbox('Enter code to confirm deletion', 'Code: '+ IntToStr(iRandom), '' ) = IntToStr(iRandom)  then // Confirm that you want to delete the account by typing over the given code
    begin
      if DeleteAccount(sedEnterCompanyID.Value) then  // If the Deletion was a success
      begin
         ShowMessage('Account of your Company deleted successfully.'+#13+ 'You will now be logged out. Goodbye') ;
         // Take user of deleted account to the welcome page
         tsManageCompany.TabVisible := False;
         tsWelcome.TabVisible := True;
         Exit;
      end;
    end
    else
    begin   //Show this if account deletion is cancelled
    ShowMessage('Deletion of account was cancelled')  ;
    Exit;
    end;
  end;

  //Validation
    sName := edtUpdateCompanyName.Text ;
    sPassword := edtUpdatePassword.Text ;
   sEmail := edtUpdateEmail.Text ;
   // Company Name
   if (sName = '') or (sName = ' ') then
   begin
     ShowMessage('Please enter your Company Name') ;
     Exit;
   end;
   // Range Check
   if not ((Length(sName) >=1) and (Length(sName) <= 30 )) then
   begin
     ShowMessage('Company Name Length should be between 1 and 30 characters');
     Exit;
   end;
   // Last character may not be a space
   if sName[Length(sName) ] = ' ' then
   begin
     ShowMessage('The last character of the name may not be a space');
     exit;
   end;
    // Check that the Company Name does not contain any elegal characters
   for I := 1 to Length(sName)  do
    begin
      if not ((sName[i] in ['A'..'Z']) or (sName[i] in ['a'..'z']) or (sName[i] in ['$', '-', ',', '.', '''', ' ']) or (sName[i] in ['0'..'9'])) then
      begin
        ShowMessage('Only alphabet characters, spaces and these special characters are allowed in the Name: '+ #13+ '$ - , . ''');
        Exit;
      end;
    end;
    // Check that the Company Name does not already exist (Check that the company has not been registered) or that the name is not changed to an existing registered Company Name
    tblCompany.first;
    while not tblCompany.Eof do
    begin
      if (UpperCase(sName) = Uppercase(tblCompany['CompanyName'])) and not (iID = tblCompany['CompanyID'])  then
      begin
        ShowMessage('Company Already Registered.');
        Exit;
      end;
      tblCompany.Next ;
    end;
    // CountryBased. Make sure that a country was entered
    if cmbUpdateCountryBased.ItemIndex = -1 then
    begin
      ShowMessage('Please Select/Enter a valid Country Based');
      Exit;
    end;
   // Password
     bNumber := False;
     bCapital := false;
     bSpecialCharacter := False;
     // Check that the password is in range
      if not ((Length(sPassword) >= 6) and (Length(sPassword) <= 20 )) then
      begin
        ShowMessage('Password Should be between 6 and 20 character long.');
        exit;
      end;
      // Check that the password is a valid passowrd
      for cChar  in sPassword  do
      begin
         bErrorCharacter := true;
        for c in arrSpecialCharacters do    // Checks that all the characters are valid
        begin
            if  (cChar = c) or (cChar in ['A'..'Z']) or (cChar in ['a'..'z']) or (cChar in ['0'..'9']) then
            begin
            bErrorCharacter := False ;
      //      break;     // exit the loop but not the procedure. Performance
            end

        end;
        if bErrorCharacter = true then
        begin
          ShowMessage('Invalid/Unsupported character in Password'+#13+'(Spaces are not allowed)')  ;
          exit;
        end ;
        // Check that password is secure
        if cChar in ['0'..'9'] then
        bNumber := True ;

        if cChar in ['A'..'Z'] then
         bCapital := True;

          if bSpecialCharacter = false then
          begin
              for c in arrSpecialCharacters  do
              begin
                 if cChar = c then
                 begin
                 bSpecialCharacter := true ;
              //   break ;   // exit the loop but not the procedure.Performance
                 end;
              end;
          end;
      end;
      // Password secure dialogue
      if not (bNumber = true and bCapital = true and bSpecialCharacter = true) then
      begin
        ShowMessage('Password does not meet the requirement.'+#13+'Password should contain atleast 1:'+#13+'-Special character'+#13+'-Capital Letter'+#13+'-Number');
        exit;
      end;
      // Make sure that you have entered the password that you think you have
      if not (sPassword = edtConfirmUpdatedPassword.Text ) then
      begin
        ShowMessage('Password do not match' )  ;
        exit;
      end;
      // Email
      if not  ValidateEmail(sEmail) then // if the email was not correct then exit the program
      exit;
     // Locate the company to upate
     tblCompany.First ;
     while not tblCompany.Eof do // Search for the company
     begin
      if tblCompany['CompanyID']= iID then   // If a matching company is found
      begin
        // Update the Companys details
        tblCompany.Edit ;

        tblCompany['CompanyName'] := sName ;
        tblCompany['Password'] := sPassword ;
        tblCompany['Email'] := sEmail ;
        tblCompany['Goverment Agency'] := chkUpdateGovernment.Checked ;
        tblCompany['Newsletter']  := chkUpdateNewsletter.Checked ;
        tblCompany['Location Based'] := cmbUpdateCountryBased.Items[cmbUpdateCountryBased.ItemIndex] ;
        tblCompany['Defualt Hours'] := sedUpdateDefaultHours.Value ;

        tblCompany.Post ;
        ShowMessage('Company Updated Successfully') ;
       Exit; // Prevent the loop from continueing after all updates  is done
      end;
       tblCompany.Next ;
     end;
end;

procedure TfrmVolitant_Express.BitBtUpdateADminClick(Sender: TObject);
begin
// Update/ Add the admin account to the database
ShowMessage(tblAdmins['Username'])
end;

procedure TfrmVolitant_Express.btnAboutUsClick(Sender: TObject);
begin
// Gives some background information about the company
// showmess
end;

procedure TfrmVolitant_Express.btnAddCategotyClick(Sender: TObject);
var
  sCategoryAdd, sLine : string ;
  tFile : TextFile ;
begin
// Add an item category

  sCategoryAdd := InputBox('Please type the category you would like to add:','*No duplicates allowed','') ;
  // Check that a category was entered
  if (sCategoryAdd = '') or (sCategoryAdd = ' ') then
  begin
    ShowMessage('No category entered');
    exit;
  end;
  // Check that the category is in Range
  if Length(sCategoryAdd) > 40  then
  begin
      ShowMessage('Category should be shorter or equel to 40 characters');
    exit;
  end;
// Check that the category does not exit already
    AssignFile(tFile, 'Item_Categories.txt');

  if not FileExists('Item_Categories.txt')  then  // Check that the file exists
  begin
    ShowMessage('Item_Categories.txt not Found, created');
    Rewrite(Tfile)  ;
  end;
  Reset(tFile) ;
     // Search for categories
  while not Eof(tfile)  do
  begin
    Readln(tFile, sLine) ;

    if UpperCase(sLine) = UpperCase(sCategoryAdd)   then // If the category already exists
    begin
      ShowMessage('Category already exists!') ;
      CloseFile(tFile) ;
      Exit;
    end;
  end;

  // Add item t otxt file if category does not exist
  Append(tFile);
  Writeln(tFile, sCategoryAdd) ;

  CloseFile(tFile);
  ShowMessage('Category added to combobox') ;
// Update the combobox in the end when the category has been added
cmbItemCategoryAdd.Items.Add(sCategoryAdd) ;
end;

procedure TfrmVolitant_Express.btnAddItemClick(Sender: TObject);
var
  sItemname : string;
  rPrice : real;
  bDangerous : boolean;
begin
// Add a new item to the Items table

// Validation

   // Check that a new item name was entered and that it is in range
   sItemname := edtItemAddName.Text ;
   if (sItemname = '') or (sItemname = ' ') or (Length(sItemname) > 40 ) then
   begin
      ShowMessage('No item name entered or length longer than 40 character') ;
      exit;
   end;
  // Check that the item name does not already exist
  tblItems.First ;
  while not tblItems.Eof do
  begin
    if Uppercase(sItemName) = Uppercase(tblItems['Item Name']) then
    begin
      ShowMessage('Item already exists. Update item to change anything') ;
      exit;
    end;

    tblItems.Next ;
  end;

  // Check that category is selected
  if cmbItemCategoryAdd.ItemIndex = -1 then
  begin
    ShowMessage('Please select item category') ;
    exit;
  end;

  // Check that a price is entered
  if sedAddItemRands.Value = 0 then
  begin
    ShowMessage('Enter the cost per kg for the item in Rands');
    exit;
  end;

// Remember to also validate that the description entered is shorted than the amount of characters that is allowed in that field in the db (120 at this time of writing)
  if Length(redAddDescription.Text) > 120  then
  begin
    ShowMessage('Item description should not exeed a length of 120 characters. (Currently: '+IntToStr(length(redAddDescription.Text)) +')');
    exit;
  end;

  // Add item to the database
  if chkDangerousItemAdd.Checked then
  bDangerous := true
  else
  bDangerous := False;
       // Get the price for the item
  rPrice :=sedAddItemRands.Value + (sedItemAddCents.Value  * 0.01);
{ qrySQL.SQL.Text := 'INSERT INTO tblItems (Item Name, Category, T_Cost/kg, Dangerous, Note, Retired) VALUES ('+QuotedStr(sItemname)+','+ QuotedStr(cmbItemCategoryAdd.Items[cmbItemCategoryAdd.ItemIndex]) +','+ FloatToStr(rPrice)+',' + BoolToStr(bDangerous) +','+ quotedStr(redAddDescription.Text)+','+ 'False' + ')';
  qrySQL.ExecSQL ;  }
        // ADO coding
  tblItems.Insert ;
   tblItems['Item Name'] := sItemname ;
   tblItems['Category']:= cmbItemCategoryAdd.Items[cmbItemCategoryAdd.ItemIndex];
   tblItems['T_Cost/kg'] := rPrice;
   tblItems['Dangerous']  := bDangerous ;
   tblItems['Note']:= redAddDescription.Text ;
   tblItems['Retired'] := False;
  tblItems.Post ;

  //  Update the list box
  lstSelectItemManage.Items.Add(sItemname +' -- ' + cmbItemCategoryAdd.Items[cmbItemCategoryAdd.ItemIndex] + ' -- ' +floattostrf(rPrice, ffCurrency, 10,2)) ;

  // Add item to a list box
  ShowMessage('Item successfully added');
  // Clear the inputs
  edtItemAddName.Clear ;
  cmbItemCategoryAdd.ItemIndex := -1;
  sedAddItemRands.Value := 0 ;
  sedItemAddCents.Value := 0 ;
  chkDangerousItemAdd.Checked := False;
  redAddDescription.Clear ;
end;

procedure TfrmVolitant_Express.btnAddPlaneClick(Sender: TObject);
var
  sPlaneName : string ;
begin
// Add a plane to the database

  // Validation
     // Check that a new item name was entered and that it is in range
   sPlaneName := edtAddPlaneName.Text ;
   if ( sPlaneName = '') or ( sPlaneName = ' ') or (Length( sPlaneName) > 40 ) then
   begin
      ShowMessage('No plane name entered or length longer than 40 character') ;
      exit;
   end;
   {
  // Check that the plane name does not already exist
  tblPlanes.First ;
  while not tblPlanes.Eof do
  begin
    if Uppercase( sPlaneName) = Uppercase(tblPlanes['Plane Name']) then
    begin
      ShowMessage('Plane already exists. Update plane to change anything') ;
      exit;
    end;
    tblPlanes.Next ;
  end;}
  // Check that a max load was entered
  if sedAddPlaneMLoad.Value = 0 then
  begin
    ShowMessage('Enter price max load in Kg');
    exit;
  end;
  // Check that the cruising speed was entered
  if sedAddPlaneCSpeed.Value = 0 then
  begin
    ShowMessage('Enter plane cruising speed in km/h') ;
    exit ;
  end;
  // Check that a max distance was entered
  if sedAddPlaneMDistance.Value = 0 then
  begin
    ShowMessage('Enter plane max flight distance in km') ;
    exit;
  end;
  // Validate that a fuel price was entered
  if sedAddFuelRands.Value = 0 then
  begin
    ShowMessage('Enter a fuel price in Fuel Cost per hour in ZAR');
    exit;
  end;
  // Add item to the database

  tblPlanes.Insert;
   tblPlanes['Plane Name'] := sPlaneName ;
   tblPlanes['Max Load'] := sedAddPlaneMLoad.Value ;
   tblPlanes['Cruising Speed']:= sedAddPlaneCSpeed.Value ;
   tblPlanes['FuelCost'] := sedAddFuelRands.Value + sedAddFuelCents.Value / 100;
   tblPlanes['Max Distance'] := sedAddPlaneMDistance.Value ;
   tblPlanes['Retired'] := False ;
  { tblPlanes['Count'] := sedAddPlaneAmount.value; }
  tblPlanes.Post ;
// Update the list box
   lstManagePlane.Items.Add(IntToStr(tblPlanes['PlaneID']) +'-'+tblPlanes['Plane Name']+' -- '+ FloatToStrF(tblPlanes['FuelCost'], ffCurrency ,10,2)  );
     ShowMessage('Plane successfully added'); // Confirmation
   // Clear the inputs
   edtAddPlaneName.Clear;
   sedAddPlaneMLoad.Value := 0 ;
   sedAddPlaneCSpeed.Value := 0 ;
   sedAddPlaneMDistance.Value := 0 ;
   sedAddFuelRands.Value := 0;
   sedAddFuelCents.Value := 0 ;
end;

procedure TfrmVolitant_Express.btnAverageFuelCostClick(Sender: TObject);
begin
// Get the average costs for plane fuel per hour
qryGrid.SQL.Text := 'Select FORMAT(AVG(FuelCost), "Currency") as [Average Fuel Cost Per Hour Of Flight] from tblPlanes'  ;
qryGrid.Open ;
end;

procedure TfrmVolitant_Express.btnBackFromGalleryClick(Sender: TObject);
var
  I : integer;
begin
// Go back to the welcome page from the Gallery page
tsGallery.TabVisible := False;

  // Remove any existing dynamic compoents from the group box by freeing them from memory. I used this method in my Grade 11 PAT
  for i := sbGallery.ControlCount - 1 downto 0 do
  begin
    // Check if the control is an Image
    if sbGallery.Controls[i] is tImage then  // Is seems to be used when you are working with components and with shapes
    begin
      // Free the panel from memory and remove it from the parent owning it
      sbGallery.Controls[i].Free;
    end;
  end;


tsWelcome.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnBackHomeFromPayClick(Sender: TObject);
begin
// Go to the home page from the payment page
tsPayment.TabVisible := False;
tsHome.TabVisible := True ;
end;

procedure TfrmVolitant_Express.btnChangeFORMthemeClick(Sender: TObject);
var
  iColor : integer;
begin
// Update the theme of the Form
  if ColorDialogForm.Execute then   // Whem a color is selected from the color dialogue
  frmVolitant_Express.Color := ColorDialogFORM.Color ;  // Chnahe the forms dialogue
  // Store the color to use when starting the program again
  iColor :=ColorDialogFORM.Color ;
  // Write to file for startup theme setting
  WriteToFormTheme('Themes/formtheme.txt', iColor) ;
  ShowMessage('Form theme updated successfully') ;
end;

procedure TfrmVolitant_Express.btnCInfoBackClick(Sender: TObject);
begin
// Go back to the company info reg page from the contact info page
tsContact.TabVisible := false;
tsDetails.TabVisible := True ;
end;

procedure TfrmVolitant_Express.bttCompaniesUnpaidOrdersClick(Sender: TObject);
var
  sUnpaid: string ;
begin
// Get the amount of orders unpaid by each company, based on the admin input for the amount of orders unpia 
  // Get the amount of orders to show of companies that are unpaid
  sUnpaid := InputBox('Enter the amount of orders a company has not paid to display the company', 'Number should be 0 or larger:', '2') ;
  // Validate that a valid number was entered
  try
    if not StrToInt(sUnpaid)>= 0  then // Try to convert to integer number and check that number is larger than 0
    begin // If number is not larger than 0
      ShowMessage('Please enter an integer number 0 or larger')   ;
      exit;
    end;
    except
    begin      // If invalid number was entered
      ShowMessage('Please enter a valid number');
      exit;
    end;
  end;
  // Two tables
qryGrid.SQL.Text := 'Select tblCompany.CompanyID, CompanyName, Count(*) as [Order Unpaid] from tblOrders, tblCompany where tblCompany.CompanyID = tblOrders.CompanyID and not Status = "Canceled" and Paid =False Group By tblCompany.CompanyID, CompanyName Having Count(*) >=' + sUnpaid ;
qryGrid.Open ;
end;

procedure TfrmVolitant_Express.btnCompanyOrderOutClick(Sender: TObject);
var
  sGovernment, sPaid : string;
  bItemFound, bFirst : boolean;
begin
// Displays a list of the companies and the orders that they have places
  redCompanyOut.Clear ;

   bFirst := True;
  tblCompany.First ;
  while not tblCompany.eof do // Loop thru the companies table
  begin
   // Set the tabstops
     redCompanyOut.SelAttributes.Color := clRed;
     redCompanyOut.Paragraph.TabCount := 4;
     redCompanyOut.Paragraph.Tab[0] := 75;
     redCompanyOut.Paragraph.Tab[1] := 225;
     redCompanyOut.Paragraph.Tab[2] := 375;
     redCompanyOut.Paragraph.Tab[3] := 445;
   if bFirst = True then // Display main heading
   begin
       redCompanyOut.Lines.Add('CompanyID'+ #9+ 'Company Name'+ #9+'LocationBased'+#9+ 'Government'+ #9+'Company Age(Years)') ;
       bFirst := False;
   end;

    // Company Info display
    redCompanyOut.SelAttributes.Color := clRed ;
    if tblCompany['Goverment Agency'] = True then
    sGovernment := 'Yes'
    else
    sGovernment := 'No' ;
    redCompanyOut.Lines.Add(#13+inttostr(tblCompany['CompanyID'])+#9+tblCompany['CompanyName']+ #9+tblCompany['Location Based']+ #9+sGovernment+ #9+IntToStr(YearsBetween(Date, tblCompany['Establishment Date']) ) );


     // Setup tabstops for display of orders
    redCompanyOut.SelAttributes.Color := clGreen;
    redCompanyOut.Paragraph.TabCount := 7;
     redCompanyOut.Paragraph.Tab[0] := 65;
      redCompanyOut.Paragraph.Tab[1] := 175;
       redCompanyOut.Paragraph.Tab[2] := 300;
        redCompanyOut.Paragraph.Tab[3] := 450;
         redCompanyOut.Paragraph.Tab[4] := 550;
      redCompanyOut.Paragraph.Tab[5] := 600;
      redCompanyOut.Paragraph.Tab[6] := 690;
     redCompanyOut.Lines.Add('OrderID'+ #9+ 'Weight(kg)'+ #9 + 'Pickup Country'+ #9+'Drop-Off Country'+#9+'Status'+ #9+'Paid'+#9+'Date of Placement'+#9+'Item Name') ;

    // Get the Orders info
    tblOrders.First ;
    while not tblOrders.eof do
    begin

      if tblOrders['CompanyID'] = tblCompany['CompanyID'] then // If a order was found that is listed under the company
      begin

        // Search for the Item that's to get transported in the order
        tblItems.First ;
        bItemFound := False;
        while not tblItems.eof and (bItemFound = False) do
        begin

          if tblOrders['ItemID'] = tblItems['ItemID']  then
          begin
            bItemFound := True;

            if tblOrders['Paid'] = True then
            sPaid := 'Yes'
            else
            sPaid := 'No';

            // Set the display to display the orders info
            redCompanyOut.SelAttributes.Color := clBlack ;
            redCompanyOut.Lines.Add(inttostr(tblOrders['OrderID'])+ #9+ inttostr(tblOrders['weight'])+ #9+ tblOrders['Pickup Country']+#9+ tblOrders['Drop of Country']+#9 +tblOrders['Status']+#9+ sPaid+#9+DateToStr(tblOrders['Order Date'])+#9+tblItems['Item Name']  )   ;


          end;

        tblItems.Next;
        end;

      end;


    tblOrders.Next ;
    end;

    tblCompany.Next;
  end;


end;

procedure TfrmVolitant_Express.btnCustomSQLClick(Sender: TObject);
var
  sSQL : string ;
begin
// Run a custom SQL statement that the user entered in the edit and display in the dbg grid

sSQL := edtCustomSQL.Text;

// Validate that the length is shorter than 255 characters

  if Length(sSQL) > 255  then
  begin
       ShowMessage('Custom SQL statement is to long');
       exit;
  end;
  try   // Try, incase an invalid SQL statemnet is entered
    qrySQL.SQL.Text := sSQL;
    qrySQL.Open;
    except
    on E: Exception do // Handle the error by recieving the message
      ShowMessage('SQL/Database error: ' + E.Message);
  end;

end;

procedure TfrmVolitant_Express.btnDeleteCompanyAdminClick(Sender: TObject);
var
  iRandom : integer ;
begin
// Delete the account of the company by an admin
  // Ask for confirmation
  iRandom := RandomRange(100, 1000);
  if Inputbox('Enter code to confirm deletion', 'Code: '+ IntToStr(iRandom), '' ) = IntToStr(iRandom)  then // Confirm that you want to delete the account by typing over the given code
  begin
    if DeleteAccount(sedEnterCompanyID.Value) then  // If the Deletion was a success
    begin
      // Clear the components
      redCompanyOut.Clear ;
      sedEnterCompanyID.Value := 0;
       ShowMessage('Account of Company deleted successfully') ;
    end;
  end
  else
  ShowMessage('Deletion of account was cancelled')  ;
end;

procedure TfrmVolitant_Express.btnFormThemeDefaultClick(Sender: TObject);
begin
// Set the form theme back to the default color
frmVolitant_Express.color :=clBtnFace ;
WriteToFormTheme('Themes/formtheme.txt', clBtnFace) ;
ShowMessage('Default Form theme restored') ;
end;

procedure TfrmVolitant_Express.btnRetiredItemsCountClick(Sender: TObject);
begin
// Get the ammount of items that has been retired
qryGrid.SQL.Text := 'Select ABS(SUM(Retired)) as [Total Retired ITems] from tblItems';
qryGrid.Open ;
end;

procedure TfrmVolitant_Express.btnRetireItemClick(Sender: TObject);
begin
// retire an item or unretire it

  if lstSelectItemManage.ItemIndex = -1 then  // Select item to manage
  begin
    ShowMessage('Select item that exists') ;
    exit ;
  end;
      if  btnRetireItem.Caption = 'Retire Item' then  // If an item is retired
      begin
        btnRetireItem.Caption := 'UnRetire Item';
        ShowMessage('Item Retired; Press Update Item to finalize') ;
      end
      else
     begin // If item is unretired
        btnRetireItem.Caption := 'Retire Item';
        ShowMessage('Item UnRetired; Press Update Item to finalize');
     end;

end;

procedure TfrmVolitant_Express.btnGalleryClick(Sender:  TObject);   // Dynamic Component
const imgWidth = 480;
const imgHeight = 250;
var
  i, iLeft, iTop, iPerLineCount  : integer;
  bOne : boolean;
  tGalleryFile : TextFile ;
begin
// Shows some pictures about the company   (some of this code will have come from my Grade 11 PAT)

  // Create the dynamic components (images) that will be used to display the gallery

  if iImageCount = 0 then // Only read the files into the array ones; the first time the button is clicked
  begin

    // Get the name of the images into an array

    // Read image names from txt file to array
    AssignFile(tGalleryFile, 'Gallery/ImageNames.txt');
    if not FileExists('Gallery/ImageNames.txt')  then
    begin // Create the file if it does not exits
      Rewrite(tGalleryFile) ;
      ShowMessage('Gallery/ImageNames.txt was not found; created')   ;
      exit;
    end;

    Reset(tGalleryFile );
     // Read the file names into the array
    while not (Eof(tGalleryFile ) ) and (iImageCount < 1000) do
    begin
       Inc(iImageCount) ;

       Readln(tGalleryFile , arrFileNames[iImageCount]);
     //  ShowMessage(arrFileNames[imgWidth]);
    end;
    CloseFile(tGalleryFile ) ;
  end;

  // Create the image components and fill them with the images

  iPerLineCount := 0;
  iTop := 20;
  bOne := True;
  for I := 1 to iImageCount do
    begin
      if FileExists('Gallery/'+ arrFileNames[I])  then    // Check that the file can be opened by the system
      begin
    
      // Create the image
        imgDynamicGallery := TImage.Create(Self) ;
        imgDynamicGallery.Width := imgWidth ;
        imgDynamicGallery.Height := imgHeight ;
        
        imgDynamicGallery.OnClick	:= imgDynamicOnclick;

        // The the image
        imgDynamicGallery.Stretch := True;
        imgDynamicGallery.Picture.LoadFromFile('Gallery/'+ arrFileNames[I]) ;

        // Set the images locations

        // Set the position in the horisontal
        if bOne = True then
        begin
          iLeft := 20 ;
          bOne := False;
        end
        else
        begin
          iLeft := sbGallery.Width - 40 - imgWidth	 {iLeft + imgWidth + 40} ;
          bOne := True;
        end;

        Inc(iPerLineCount);

        imgDynamicGallery.Left := iLeft;
        imgDynamicGallery.Top := iTop;

        // Change the POS of the image in the vertical
        if iPerLineCount = 2 then
        begin
          iPerLineCount := 0;
          iTop := iTop + imgHeight+ 25 ;
        end;

        // Set the parent
        imgDynamicGallery.Parent := sbGallery ;
      
      end;
    end;

// go to the gallery tab sheet
tsWelcome.TabVisible := False;
tsGallery.TabVisible := true;
end;

procedure TfrmVolitant_Express.btnHomeThemeDefaultClick(Sender: TObject);
begin
// Return the home theme to default
  // Chnage the color grid back to its starting position
  CGhomeTheme.BackgroundIndex := 0 ;
  CGhomeTheme.ForegroundIndex := 0 ;
  // of the label
  lblWelcomeHome.font.Color := clMaroon    ;
  WriteToFormTheme('Themes/home_label_theme.txt', clMaroon) ;
  // of the group box
  grbHome.Color := clBtnFace ;
  WriteToFormTheme('Themes/home_grb_theme.txt', clBtnFace) ;
  ShowMessage('Themes of Home group box and home label restored to default') ;
end;

procedure TfrmVolitant_Express.btnIntroVidClick(Sender: TObject);
begin
// Plays the recorded intro video about the company

// go to anotherr tab sheet
tsWelcome.TabVisible := False;
tsIntroVideo.TabVisible := true ;

  mpIntroVideo.FileName := 'Program Media\Intro Video_5.wmv';  // Set the video file path
  mpIntroVideo.Display := pnlVideo;  // Assign the panel as the display window
  mpIntroVideo.Open;  // Open the video file
  mpIntroVideo.Play;  // Play the video
end;

procedure TfrmVolitant_Express.btnItemOrderPriceClick(Sender: TObject);
begin
  // Order the items from the items table according to their price
  qryGrid.SQL.Text := 'Select * from tblItems Order By [T_Cost/kg] DESC';
  qryGrid.Open ;
end;

procedure TfrmVolitant_Express.btnLastInfoBackClick(Sender: TObject);
begin
// Go back to the contact info reg page from the last info page
tsLastInfo.TabVisible := False;
tsContact.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnLoadCompanyClick(Sender: TObject);
var
  bFound : boolean;
  sGovernment, sNewsletter, sSuspended : string ;
begin
// Load every detail of the company that was entered in the spinedit

  // Validate that a company was entered
  if sedEnterCompanyID.Value = 0 then
  begin
    ShowMessage('Enter CompanyID to find') ;
    exit;
  end;
  redCompanyOut.Clear ;
  bFound := False;
  tblCompany.First ;
  while not tblCompany.eof and (bFound = False) do   // Find the company
  begin
    if tblCompany['CompanyID'] = sedEnterCompanyID.Value then // If a matching company is found
    begin
      bFound := True;
        // Set government agency string
        if tblCompany['Goverment Agency'] =True then
        sGovernment := 'Yes'
        else
        sGovernment := 'No';
        // Set newsletter string
        if tblCompany['Newsletter'] then
        sNewsletter := 'Yes'
        else
        sNewsletter := 'No' ;
        // Set the suspended string
        if tblCompany['Suspended'] then
        begin     // If the account is suspended
          sSuspended := 'Yes';
          chkSuspendAccount.Checked := True;  // Update the check box for suspension
        end
        else
         begin
            sSuspended := 'No';
            chkSuspendAccount.Checked := False;
         end;
      // Display the company info
      redCompanyOut.SelStart := 0 ;
      redCompanyOut.SelLength := 10;
      redCompanyOut.SelAttributes.Size := 14;
      redCompanyOut.lines.Add('Company Name: '+tblCompany['CompanyName']) ; // company name
      redCompanyOut.lines.Add('Username: '+tblCompany['Username']) ; // Username
      redCompanyOut.lines.Add('Password: '+tblCompany['Password']) ; // Password
      redCompanyOut.Lines.Add('Email: '+tblCompany['Email']) ;       // Email
      redCompanyOut.lines.Add('Location Based: '+tblCompany['Location Based']) ; // Location Based
      redCompanyOut.lines.Add('Government: ' + sGovernment) ; // Government agency
      redCompanyOut.lines.Add('Newsletter: '+ sNewsletter) ; // Newsletter
      redCompanyOut.lines.Add('Registration Date: ' + DateToStr(tblCompany['Regdate']) ) ;  // Reg date
      redCompanyOut.lines.Add('Company Age: ' + IntToStr(YearsBetween(Date, tblCompany['Establishment Date']) ) ) ;// date of establishment
      redCompanyOut.lines.Add('Default Hours: ' + IntToStr(tblCompany['Defualt Hours']) ) ;  // The companies defualt hours
      redCompanyOut.Lines.Add('Suspended: '+ sSuspended ) ; // suspended

    end;
  tblCompany.Next ;
  end;
    // If no company was found
  if bFound = False then
  begin
     redCompanyOut.Lines.Add('No Matching Company Found') ;
     exit;
  end;

  // enable the company controll buttons if a comany is found
   btnDeleteCompanyAdmin.Enabled := true;
  chkSuspendAccount.Enabled := true;
  btnUpdateSuspension.Enabled := True;
end;

procedure TfrmVolitant_Express.btnLoginBackClick(Sender: TObject);
begin
// Go back to the welcome page from the login page
  // Clear the fields
  edtUsernameLogin.Clear;
  edtPasswordLogin.Clear ;
  chkLoginAsAdmin.Checked := False;
  // Change the tabsheets
tsLogin.TabVisible := false;
tsWelcome.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnLoginClick(Sender: TObject);
var
  bAccountFound : boolean;
begin
// Login to the program

  if not chkLoginAsAdmin.Checked  then // Check if the user wants to login as a person or an admin
  begin
    // This is to login as a user
    tblCompany.First ;
    bAccountFound := False;
    while not tblCompany.Eof and not bAccountFound do
    begin
      if (tblCompany['Username'] = edtUsernameLogin.Text) and (tblCompany['PAssword'] = edtPasswordLogin.Text) then
      begin // If a company was found
         if tblCompany['Suspended'] = False then  // if the account is not suspended
          begin
           iID := tblCompany['CompanyID'] ; // Set the ID variable
           bAccountFound := True;
           ShowMessage('Logged in succesfully!');
            // Change the tabsheets
           tsLogin.TabVisible := False;
           tsHome.TabVisible := True ;
          end
          else
          begin // If the account is suspended
            ShowMessage('Account is suspended'+ #13+'Contact admins to resolve your issue'+#13+'Admin email: 10867@hsrandburg.co.za')  ;
          end;
      end;
      tblCompany.Next ;
    end;

    if not bAccountFound  then
    begin
       Showmessage('Invalid Password or username!') ;
       exit;
    end;
  end
  else
  begin // This is to login as an admin
    tblAdmins.First ;
    bAccountFound := FAlse;
    while not tblAdmins.Eof and not (bAccountFound) do
    begin
      if (tblAdmins['Username'] = edtUsernameLogin.Text) and (tblAdmins['Password'] = edtPasswordLogin.Text) then
      begin // IF a valid admin login is found
        bAccountFound := True ;
        // Change tabsheets
        tsLogin.TabVisible := FAlse;
        tsAdmin.TabVisible := True ;
        // Set the admin name feature
        lblAdmin.Caption := 'Welcome, ADMIN named '+ tblAdmins['Username'] ;
          // apply account permissions
            // Apply admin management permission
            if tblAdmins['Manage_Admins'] then   // If allowed to manage admins
            begin
            btnToAdminManage.Enabled := True ;
            btnToAdminManage.ShowHint := False;
            end
            else
            begin // If not allowed to manage admins
              btnToAdminManage.Enabled := false ;
            {  btnToAdminManage.ShowHint := True;
              btnToAdminManage.Hint := 'You do not have permission to access this page' ; }
            end;
            // Apply admin Developer Settings
            if tblAdmins['Developer'] then  // If the admin is a developer
            begin
              btnToCustom.Enabled := True;
              btnToCustom.ShowHint := False;
            end
            else
            begin // If the admin account is not a developer account
              btnToCustom.Enabled := False;
            end;
            // Apply admin theme change settigs
            if tblAdmins['Change_Theme'] then   // If the admin is allowed to change the theme
            begin
              btnToTheme.Enabled := True ;
              btnToTheme.ShowHint := False;
            end
            else
            begin // If the admin is not allowed to change the them
              btnToTheme.Enabled := False;
            end;
            // Apply admin item manage permissions
            if tblAdmins['Item_Manage'] then  // If allowed to manage items
            begin
              btnToItems.Enabled := True;
              btnToItems.ShowHint := false;
            end
            else
            begin // If not allowed to manage items
              btnToItems.Enabled := False;
            end;
            // Apply admin plane manage permissions
            if tblAdmins['Plane_Manage'] then  // If allowed to manage planes
            begin
              btnToPlanes.Enabled := True;
              btnToPlanes.ShowHint := False;
            end
            else
            begin // If not allowed to manage planes
                btnToPlanes.Enabled := False;
            end;
            // Apply Newsetter send permissions
            if tblAdmins['Newsletter'] then   // If allowed to send the newsletter
            begin
              btnToEmails.Enabled := True ;
              btnToEmails.ShowHint := False;
            end
            else
            begin   // If not allowed to send emails
               btnToEmails.Enabled := false ;
            end;
      end;
      tblAdmins.Next ;
    end;

    if not bAccountFound then  // If admin login failed
    begin
      ShowMessage('Invalid login details to login as an admin') ;
      exit;
    end;
  end;
end;

procedure TfrmVolitant_Express.btnLoginGOClick(Sender: TObject);
begin
// Go to the Login page
tsWelcome.TabVisible :=  false ;
tsLogin.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnLoginMouseEnter(Sender: TObject);
begin
// When the mouse goes over the login button
  btnLogin.Width := 640;
  btnLogin.Height := 100;
    btnLogin.Left := 303-14;
  btnLogin.Top := 432-9;
end;

procedure TfrmVolitant_Express.btnLoginMouseLeave(Sender: TObject);
begin
// Set the login buttons size back to the default when the mouse leaves
 btnLogin.Width := 612;
  btnLogin.Height := 73;
  btnLogin.Left := 303;
  btnLogin.Top := 432;
end;

procedure TfrmVolitant_Express.btnManageCompanyClick(Sender: TObject);
var
  I : integer ;
  bCompanyFound : boolean ;
begin
// Go to the page to manage company info page from the home page
tsHome.TabVisible := False;

   // Load the countries into selection boxe for the Update Country based
    cmbUpdateCountryBased.Clear ; // Clears any txt that may have been in the comboBox
    for I := 1 to iCountryCount do
    cmbUpdateCountryBased.Items.Add(arrCountryName[i]) ;

    // Load the companies data to the fields
 // Find the company
  bCompanyFound := False ;
  tblCompany.First ;
  while not tblCompany.Eof and (bCompanyFound = False) do // Search for the Company
  begin
    if tblCompany['CompanyID'] = iID  then  // If a matching company is found
    begin
      bCompanyFound := True;
      // Fill the components for updating
      edtUpdateCompanyName.Text := tblCompany['CompanyName'];
      edtUpdatePassword.Text := tblCompany['Password'];
      edtConfirmUpdatedPassword.Text  := tblCompany['Password'];
      edtUpdateEmail.Text := tblCompany['Email'];
      // Set the combobox
      for I := 0 to iCountryCount-1  do
        begin
          if cmbUpdateCountryBased.items[i] =  tblCompany['Location Based'] then // if a matching item is found
          begin
            cmbUpdateCountryBased.ItemIndex := i;
     //       Break; // End the loop once a matching record is found to save performance
          end;
        end;
      sedUpdateDefaultHours.Value := tblCompany['Defualt Hours'];
      chkUpdateGovernment.Checked := tblCompany['Goverment Agency'];
      chkUpdateNewsletter.Checked := tblCompany['Newsletter'];
    end;
    tblCompany.Next ;
  end;

tsManageCompany.TabVisible := true;
end;

procedure TfrmVolitant_Express.btnOrderPhaseAdminClick(Sender: TObject);
var
  bItemFound : boolean;
  sPaid : string;
begin
// Search and list orders that are in a spesific phase

// Validation
  if cmbOrderPhaseSearch.ItemIndex = -1 then
  begin
    ShowMessage('Select phase to search from above box') ;
    exit;
  end;

  // Search and display orders in phase
    // Set tab stops
    redorderout.Clear ;
     redOrderOut.Font.Size := 9;
    // Set heading for search
    redOrderOut.SelAttributes.Size := 14;
   redOrderOut.Lines.Add('Order in phase: '+ cmbOrderPhaseSearch.Items[cmbOrderPhaseSearch.ItemIndex]) ;
     // Setup tabstops for display of orders in that phase
    redOrderout.SelAttributes.Color := clGreen;
    redOrderout.Paragraph.TabCount := 8;
      redOrderout.Paragraph.Tab[0] := 60;   // OrderID
  redOrderout.Paragraph.Tab[1] := 130;  // CompanyID
  redOrderout.Paragraph.Tab[2] := 210;  // Weight(kg)
  redOrderout.Paragraph.Tab[3] := 300;  // Pickup Country
  redOrderout.Paragraph.Tab[4] := 440;  // Drop-Off Country
  redOrderout.Paragraph.Tab[5] := 580;  // Status
  redOrderout.Paragraph.Tab[6] := 650;  // Paid
  redOrderout.Paragraph.Tab[7] := 720;  // Date of Placement
    redOrderout.Lines.Add('OrderID'+#9+'CompanyID'+ #9+ 'Weight(kg)'+ #9 + 'Pickup Country'+ #9+'Drop-Off Country'+#9+'Status'+ #9+'Paid'+#9+'Date of Placement'+#9+'Item Name'+ #13) ;

    // find the orders
    tblOrders.First;
    while not tblOrders.Eof do
    begin
        if tblOrders['Status'] = cmbOrderPhaseSearch.Items[cmbOrderPhaseSearch.ItemIndex]  then // If a order was found that is listed under the status beign searched for
        begin
          // Search for the Item that's to get transported in the order
          tblItems.First ;
          bItemFound := False;
          while not tblItems.eof and (bItemFound = False) do
          begin

            if tblOrders['ItemID'] = tblItems['ItemID']  then
            begin
              bItemFound := True;
                // Get if the order was paid in string form
              if tblOrders['Paid'] = True then
              sPaid := 'Yes'
              else
              sPaid := 'No';

              // Set the display to display the orders info
              redOrderOut.SelAttributes.Color := clBlue  ;
              redOrderOut.Lines.Add(inttostr(tblOrders['OrderID'])+ #9+inttostr(tblOrders['CompanyID'])+#9+ inttostr(tblOrders['weight'])+ #9+ tblOrders['Pickup Country']+#9+ tblOrders['Drop of Country']+#9 +tblOrders['Status']+#9+ sPaid+#9+DateToStr(tblOrders['Order Date'])+#9+tblItems['Item Name']  )   ;
            end;
          tblItems.Next;
          end;

        end;
        tblOrders.Next ;
    end;
end;

procedure TfrmVolitant_Express.btnOrdersOutstandingPaymentClick(Sender: TObject);
var
  bItemFound : boolean ;
  sPaid : string;
  iUnpaidCount : integer;
begin
// Display all orders with outstandigng payments. Exlude canecelled orders
  redOrderOut.Clear ;
   redOrderOut.Font.Size := 9;
     // Setup tabstops for display of orders in that phase
    redOrderout.SelAttributes.Color := clPurple ;
    redOrderout.Paragraph.TabCount := 8;
      redOrderout.Paragraph.Tab[0] := 60;   // OrderID
  redOrderout.Paragraph.Tab[1] := 130;  // CompanyID
  redOrderout.Paragraph.Tab[2] := 210;  // Weight(kg)
  redOrderout.Paragraph.Tab[3] := 300;  // Pickup Country
  redOrderout.Paragraph.Tab[4] := 440;  // Drop-Off Country
  redOrderout.Paragraph.Tab[5] := 580;  // Status
  redOrderout.Paragraph.Tab[6] := 650;  // Paid
  redOrderout.Paragraph.Tab[7] := 720;  // Date of Placement
    redOrderout.Lines.Add('OrderID'+#9+'CompanyID'+ #9+ 'Weight(kg)'+ #9 + 'Pickup Country'+ #9+'Drop-Off Country'+#9+'Status'+ #9+'Paid'+#9+'Date of Placement'+#9+'Item Name'+ #13) ;

    // find the orders
    iUnpaidCount := 0 ;
    tblOrders.First;
    while not tblOrders.Eof do
    begin
        if (tblOrders['Paid'] = False) and not (tblOrders['Status'] = 'Canceled')  then // If a order was found that's not paid and not cancelled
        begin
          // Search for the Item that's to get transported in the order
          tblItems.First ;
          Inc(iUnpaidCount);
          bItemFound := False;
          while not tblItems.eof and (bItemFound = False) do
          begin

            if tblOrders['ItemID'] = tblItems['ItemID']  then
            begin
              bItemFound := True;
                // Get if the order was paid in string form
              if tblOrders['Paid'] = True then
              sPaid := 'Yes'
              else
              sPaid := 'No';

              // Set the display to display the orders info
              redOrderOut.SelAttributes.Color := clBlue  ;
              redOrderOut.Lines.Add(inttostr(tblOrders['OrderID'])+ #9+inttostr(tblOrders['CompanyID'])+#9+ inttostr(tblOrders['weight'])+ #9+ tblOrders['Pickup Country']+#9+ tblOrders['Drop of Country']+#9 +tblOrders['Status']+#9+ sPaid+#9+DateToStr(tblOrders['Order Date'])+#9+tblItems['Item Name']  )   ;
            end;
          tblItems.Next;
          end;

        end;
        tblOrders.Next ;
    end;
    // Dispaly a counter
    redOrderOut.SelAttributes.Size := 13;
    redOrderOut.Lines.Add(#13+'There are a total of ' + IntToStr(iUnpaidCount)+ ' unpaid orders' ) ;
end;

procedure TfrmVolitant_Express.btnOrderSumAdminClick(Sender: TObject);
var
  rAveWeight, rAveDistance  : real;
  iOrderCount, iTotalMinutes : integer ;
  sAvePickupTime : string;
begin
// Give a summary about stats everything order related
  redOrderOut.Clear ;
  redOrderOut.Font.Size := 12;
   // Set the variables
   rAveWeight := 0;
   rAveDistance := 0 ;
   iTotalMinutes := 0;
   iOrderCount := 0 ;

  tblOrders.First;
  while not tblOrders.eof do  // loop thru the order table to gather stats
  begin
    // Get the totals
    rAveWeight := rAveWeight + tblOrders['Weight'] ;
    rAveDistance := rAveDistance + tblOrders['Distance'] ;
    iTotalMinutes := iTotalMinutes + MinuteOf(tblOrders['Pickup Date']) + HourOf(tblOrders['Pickup Date']) * 60; // Convert the time to minutes as a common 'time keeping' thing  
    Inc(iOrderCount );
    tblOrders.next;
  end;

  if iOrderCount = 0 then // Only if there are orders in the database; just to be sure to prevent errors 
  exit;
    // Average order weight
    rAveWeight := rAveWeight / iOrderCount ;
    redOrderOut.Lines.Add('Average Order Weight: '+ FloatToStrF(rAveWeight, ffCurrency , 10,2)+ ' kg' );
    // Average order distance of transportation
    rAveDistance := rAveDistance / iOrderCount ;
    redOrderOut.Lines.Add('Average order Transportation Distance: '+ floattostrF(rAveDistance, ffFixed , 10,2)+ ' km');
    // Average pickup time     
    iTotalMinutes := Round(iTotalMinutes / iOrderCount) ;
    sAvePickupTime :=  IntToStr(iTotalMinutes div 60) + ' : ' + IntToStr(iTotalMinutes mod 60);
    redOrderOut.Lines.Add('Average Pickup TIME for orders: ' + sAvePickupTime  + '  (in 24 hour format)'); 
    
  // Calculate the most made trip between countries
  qrySQL.SQL.Text := 'Select TOP 1 [Pickup Country], [Drop of Country], COUNT(*) AS TripCount from tblOrders Group By [Pickup Country], [Drop of Country] Order By Count(*) DESC';
  qrySQL.Open ;
  // Get the most done trips; there can be more than one
   redOrderOut.Lines.Add('Top trips between countries from Pickup Country: ')   ;
  qrySQL.First ;
  while not qrySQL.eof do
  begin
     redOrderOut.Lines.Add(qrySQL['Pickup Country']+ '  --  '+ qrySQL['Drop of Country']) ;
   qrySQL.Next ;
  end;

  // Calculate the top items being used in orders
  qrySQL.SQL.Text := 'Select tblOrders.ItemID,  [Item Name], Category, [T_Cost/kg], Count(*) as ItemUseCount from tblItems, tblOrders where tblOrders.ItemID = tblItems.ItemID Group By [Item Name], Category, [T_Cost/kg], tblOrders.ItemID Order By Count(*) DESC' ;
  qrySQL.Open ;
  // Retrive and display the stats collected from the query

  redOrderOut.Lines.Add(#13+ 'Most transported items Sorted from Most to Least:'+ #13) ;
  redOrderOut.SelAttributes.Color := clGreen;
  // Set the tab stops
  redOrderOut.Paragraph.TabCount := 4;
  redOrderOut.Paragraph.Tab[0] := 60;
  redOrderOut.Paragraph.Tab[1] := 220;
  redOrderOut.Paragraph.Tab[2] := 340;
  redOrderOut.Paragraph.Tab[3] := 470;
  redOrderOut.Lines.Add('Item ID' + #9+'Item Name'+ #9+ 'Category'+ #9+ 'Cost per KG'+ #9+ 'Transported Count') ;// Set the heading
  qrySQL.First ;
  while not qrySQL.eof do   // Loop thru the SQL results and display in the rich edit
  begin
  redOrderOut.Lines.Add(IntToStr(qrySQL['ItemID'])+#9+qrySQL['Item Name']+ #9+ qrySQL['Category']+ #9+ FloatToStrF(qrySQL['T_Cost/kg'], ffCurrency , 10,2)+ #9+ IntToStr(qrySQL['ItemUseCount'])   );
  qrySQL.Next ;
  end;
end;

procedure TfrmVolitant_Express.btnOrderToSummaryClick(Sender: TObject);
var
  rBaseCost, rLatPickup, rLongPickup, rLatDropOff, rLongDropOff, rWeight,   rHoursTripLength, rTotalCost : real;
  I, iPlaneID: Integer;
  dtPickupDate, dtDropOffDate : TDateTime ;
  sTrip: string;
begin
// Go to the order summary tab page
  // Validation
    // Ensure an item is selected
    if lstSelectTransportItem.ItemIndex = -1 then
    begin
      ShowMessage('Please select a valid Item!');
      exit
    end;
   // Ensure that a weight larger than 1 kg has been entered
   if not (sedAddOrderKg.Value >= 1) then
   begin
     ShowMessage('Order Weight must be larger or equel than 1 kg');
     exit;
   end;
   // Ensure that Pickup country has been selected
   if cmbSelectPickupCountry.ItemIndex = -1 then
   begin
     ShowMessage('Please select a valid Pickup Country');
     exit;
   end;
   // Ensure that a Drop off country has been selected
   if cmbSelectDropOffCountry.ItemIndex = -1 then
   begin
     ShowMessage('Please select a valid Drop Off Country');
     exit;
   end;
   // Ensure that the Pickup and Dropf Off Countries are not the same country
   if cmbSelectPickupCountry.ItemIndex = cmbSelectDropOffCountry.ItemIndex then
   begin
     ShowMessage('Pickup and Drop off Countries may not be the smae place') ;
     exit;
   end;
  // Ensure date and time for pickup is atleast a day in the future from current time
  dtPickupDate := dtpChoosePickupDate.Date + tpChoosePickupTime.Time ;
  if  (hoursBetween(Now, (dtPickupDate))  < 24) then
  begin
    ShowMessage('Your selected pickup date and time must be atleast 24 hours into the future from the Current Date and time');
    exit ;
  end;
    // Get the coordinates for the countries
    for I := 1 to iCountryCount do
    begin
       if UpperCase(cmbSelectPickupCountry.Items[cmbSelectPickupCountry.ItemIndex]) = UpperCase(arrCountryName[i])   then  // Get the coordinates for the Pickup Country if a matching country is found
       begin
          rLatPickup := arrLatitude[i] ;
          rLongPickup := arrLongitude[i];
       end
       else
       if UpperCase(cmbSelectDropOffCountry.Items[cmbSelectDropOffCountry.ItemIndex]) = UpperCase(arrCountryName[i]) then   // Get the coordinates for the DropOff Country if a matching country is found
       begin
          rLatDropOff := arrLatitude[i] ;
          rLongDropOff := arrLongitude[i];
       end;
    end;
    // Calculate the Base Cost
    qrySQL.SQL.Text := 'Select * from tblCompany where CompanyID = ' + IntToStr(iID)  ;  // Get the company details
    qrySQL.Open ;
    rBaseCost := CalcBaseCost(qrySQL['Goverment Agency'], qrySQL['Establishment Date']) ;   // Cal the calc base cost function

  // Get the distance for the order
 objDistance := TDistance.Create(rLatPickup, rLatDropOff, rLongPickup, rLongDropOff,cmbSelectPickupCountry.Items[cmbSelectPickupCountry.ItemIndex],cmbSelectDropOffCountry.Items[cmbSelectDropOFFCountry.ItemIndex]  ) ;// Initialize the class
 sTrip :=objDistance.ToString ;
 // Get the weight of the order
 rWeight := sedAddOrderKg.Value + (sedOrderGrams.Value / 100) ;

  // Find a plane for the transporting operation
 iPlaneID := FindPlane(rWeight,objDistance.GetDistance,  dtPickupDate )   ;

 if iPlaneID = 0 then // If no plain that can do the trip is found
 begin
  ShowMessage('Unfortunatly, no plane that can transport the order was found for the trip')   ;
  exit;
 end;

 if iPlaneID = -1 then   // If no available plain that can do the trip is found
 begin
   ShowMessage('No available plane was found that is capable of transporting the order,'+ #13+ 'Choose another Pickup Date to transport the order');
   exit;
 end;

    // Get the plane info for the selected plain- again :(
    qrySQL.SQL.Text := 'Select * from tblPlanes where PlaneID = ' + IntToStr(iPlaneID) ;
    qrySQL.Open ;
    // Get the dropOff DateTime
    rHoursTripLength := objDistance.GetDistance / qrySQL['Cruising Speed'];
    dtDropOffDate := dtPickupDate + (rHoursTripLength / 24) ;
    // Calc the total cost of the order
    rTotalCost := rBaseCost ;   // Set the total cost to the base cost of the order
    rTotalCost := rTotalCost + qrySQL['FuelCost'] * rHoursTripLength ; // Add the fuel cost price to the total price
    // Get the item transport cost per kg
    qryGrid.SQL.Text := 'Select * from tblItems where [Item Name] = ' + QuotedStr(lstSelectTransportItem.Items[lstSelectTransportItem.ItemIndex]);
    qryGrid.Open ;
    rTotalCost := rTotalCost + rWeight *  qryGrid['T_Cost/kg']  ;
    // Write to the summary page
    redOrderSummary.Clear ;
    redOrderSummary.SelAttributes.Size := 22;
     redOrderSummary.SelAttributes.Color := clPurple ;
      redOrderSummary.Lines.Add('Order Summary') ;
      redOrderSummary.Lines.Add('');
      redOrderSummary.Lines.Add('CompanyID: '+ IntToStr(iID) ) ;
       redOrderSummary.Lines.Add('Item: ' + lstSelectTransportItem.Items[lstSelectTransportItem.ItemIndex] + ' -From the Category ' + qryGrid['Category']) ;
       redOrderSummary.Lines.Add('Weight : ' + FloatToStrf(rWeight, ffFixed , 10,2) + ' kg') ;
         redOrderSummary.Lines.Add('Plane: '+ qrySQL['Plane Name'])  ;
          redOrderSummary.Lines.Add('Pickup Date/Time: '+ DateTimeToStr(dtPickupDate) )  ;
           redOrderSummary.Lines.Add('DropOff Date/Time: '+ DateTimeToStr(dtDropOffDate) );
           redOrderSummary.Lines.Add(sTrip) ;
           redOrderSummary.SelAttributes.Color := clRed ;
       redOrderSummary.Lines.Add('Total Cost: '+ FloatToStrF(rTotalCost, ffCurrency , 10,2) );

// Change Tab sheets to the summary page
tsPlaceOrder.TabVisible := False ;
tsOrderSummary.TabVisible := true;
end;

procedure TfrmVolitant_Express.btnPauseVidClick(Sender: TObject);
begin
// Pause the video
mpIntroVideo.Pause ;
end;

procedure TfrmVolitant_Express.btnPlayVidClick(Sender: TObject);
begin
// Play the video if the video was paused
mpIntroVideo.Resume ;
end;

procedure TfrmVolitant_Express.btnPopularDropOffCounriesClick(Sender: TObject);
begin
// Get the DropOff Counties that are used more than once, and which orders are not cancelled and have been paid
qryGrid.SQL.Text :='Select [Drop of Country], Count(*) as [Times Dropped Off] from tblOrders where not (Status = "Canceled") and (Paid = True) Group By [Drop of Country] Having Count(*) > 1';
qryGrid.Open ;
end;

procedure TfrmVolitant_Express.btnRegBackClick(Sender: TObject);
begin
// Go back to the Welcome page from the Register page
tsRegister.TabVisible := False;
tsWelcome.TabVisible := True ;
// Clear all of the registration fields
edtCName.Clear ;
chkGovernment.Checked := False;
cmbCountryBased.ItemIndex :=-1;
edtCreatePassword.Clear ;
edtConfirmPass.Clear ;
imgBasedFlag.Visible := False;
edtRegEmail.Clear ;
chkNewsLetter.Checked := FAlse;
dtpEstablishedDate.Date := Today;
sedRegDefaultHours.Value := 24;

// Set the register page controll to the starting page
pgcRegister.ActivePage.TabVisible := False;
tsDetails.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnRegisterGOClick(Sender: TObject);
begin
// Go to the register page
tsWelcome.TabVisible := false ;
dtpEstablishedDate.Date := Date;
tsRegister.TabVisible := True ;
end;

procedure TfrmVolitant_Express.btnRegRestartClick(Sender: TObject);
begin
// Restarts the Regestration from the begining, does not clear any fields
chkConfirmRegInfo.Checked := False;
tsRegConfirm.TabVisible := False;
tsDetails.TabVisible := True ;
end;

procedure TfrmVolitant_Express.btnReloadSumClick(Sender: TObject);
const RevenueGoal = 1000000000;
const OrdersGoal = 100;
var
  iNum, iYearlyOrdersGoal : integer ;
  sString, sFileName, sLine : string;
  rRevenue, rHours, rYearlyRevenueGoal : real;
  bFound : boolean;
  tFile : textFile ;
begin
// Reloads the page; updating the info

 // Total Accounts
 pnlTotalAccounts.Caption := 'Total Accounts: ' + IntToStr(tblCompany.RecordCount); 
 // total Orders
 pnlTotalOrders.Caption :='Total Orders: '+ IntToStr(tblOrders.RecordCount );
 // Total Items
 pnlTotalItems.Caption := 'Total Items: ' + IntToStr(tblItems.RecordCount) ;
 // Total Planes
 qrySQL.SQL.Text := 'Select count(*) as Result from tblPlanes' ;
 qrySQL.Open ;
 pnlTotalPlanes.Caption := 'Total Planes: ' + IntToStr(qrySQL['Result']) ;

 // Top plain
 qrySQL.SQL.Text := 'SELECT TOP 1 PlaneID AS Result FROM tblOrders Group By PlaneID ORDER BY Count(*) DESC';
  qrySQL.Open ;
 iNum := qrySQL['Result'];
 qrySQL.SQL.Text := 'Select [Plane Name] as Result from tblPlanes where PlaneID = '+ IntToStr(iNum);
 qrySQL.Open ; 
 sString := qrySQL['Result'];
  lblTopPlain.Caption := 'Top Plain: ' + sString ;

  //  Top Item
  qrySQL.SQL.Text := 'Select TOP 1 [Item Name] As Result from tblItems, tblOrders where tblOrders.ItemID = tblItems.itemID Group By tblItems.[Item Name] ORDER BY Count(*) DESC'; 
  qrySQL.Open ;
  lblTopItem.Caption := 'Top Item: ' + qrySQL['Result'];

  // Top Pickup Country
  qrySQL.SQL.Text := 'Select TOP 1 [Pickup Country] as Result from tblOrders Group By [Pickup Country] Order By Count(*) DESC'  ;
   qrySQL.Open ;
   lblTopPickupC.Caption := 'Top Pickup Country: ' + qrySQL['Result'] ;

   // Drop of Country
   qrySQL.SQL.Text := 'Select TOP 1 [Drop of Country] as Result from tblOrders Group By [Drop of Country] Order By Count(*) DESC'  ;
   qrySQL.Open ;
   lblTopDropoffC.Caption := 'Top Drop-Off Country: ' + qrySQL['Result'] ;

   // Total Revenue for all time calculation
   rRevenue := 0 ;
   rYearlyRevenueGoal := 0 ;
   iYearlyOrdersGoal := 0;
   tblOrders.First ;
   while not tblOrders.eof do   // Loop thru tblOrders
   begin
      if tblOrders['Paid'] = true then   // Checks that the order has been paid, before adding it to revenue sum
      begin
        rRevenue := rRevenue + tblOrders['Base Cost'] ; // Add the base cost to total revenue

        if (YearOF(tblOrders['Pickup Date']) = YearOf(Date))  then // inc the orders that occured this year specificaly counter
        Inc(iYearlyOrdersGoal) ;

        // Get the price of the Item/kg and FuelCost/hour from the txt file log
        sFileName := 'History_Log/' + inttostr(tblOrders['OrderID']) + '.txt'   ;
        if not FileExists(sFileName)  then
        begin // If the file containing the prices does not exist
          // Create the file
          AssignFile(tFile, sFileName) ;
          Rewrite(tFile);
        //  Append(tFile);
          // Get the item Price/kg for transport
             tblItems.First ;
            bFound := False;
            while not tblItems.eof and (bFound = false) do // Loop thru items table to get the price for an item per kg
            begin
              if tblItems['ItemID'] = tblOrders['ItemID'] then
              begin
              bFound := true;
                rRevenue := rRevenue + tblItems['T_Cost/kg'] * tblOrders['Weight'] ;
                 if (YearOF(tblOrders['Pickup Date']) = YearOf(Date))  then  // increase the revenue that was made this year only
                 rYearlyRevenueGoal := rYearlyRevenueGoal +  tblItems['T_Cost/kg'] * tblOrders['Weight'] ;

                 Writeln(tFile, FloatToStr(tblItems['T_Cost/kg']) ); // Write the current price of the item/kg to the txt file
              end;
              tblItems.Next ;
            end;
            // Get the FuelCost/hour for the plane being used
            bFound := False ;
            tblPlanes.First;
            while not tblPlanes.Eof and (bFound = false) do
            begin
               if tblPlanes['PlaneID'] = tblOrders['PlaneID'] then
               begin
                  bFound := True;
                  // Calculate the hours that the flight will last
                  rHours  := (tblOrders['E/D Date'] - tblOrders['Pickup Date']) * 24 ; // Get the difference in time and convert it to hours
                  rRevenue := rRevenue + tblPlanes['FuelCost']  * rHours  ; // times by the hours of the flight
                     if (YearOF(tblOrders['Pickup Date']) = YearOf(Date))  then  // increase the revenue that was made this year only
                 rYearlyRevenueGoal := rYearlyRevenueGoal +  tblPlanes['FuelCost']  * rHours  ;

                  Writeln(tFile, FloatToStr(tblPlanes['FuelCost'])  )  ; // Write the current FuelCost/hour of flight of the plane to the txt file
               end;
              tblPlanes.Next ;
            end;
            CloseFile(tFile) ;
        end
        else
        begin // If the file containing the Orders prices was found
           AssignFile(tFile, sFileName);
           Reset(tFile);
           // Get the item price at the time of placing the order
             Readln(tFile, sLine)  ;
             rRevenue := rRevenue + StrToFloat(sLine)  * tblOrders['Weight'] ;
                   if (YearOF(tblOrders['Pickup Date']) = YearOf(Date))  then  // increase the revenue that was made this year only
                   rYearlyRevenueGoal := rYearlyRevenueGoal +   StrToFloat(sLine) * tblOrders['Weight'] ;
           // Get the price of the Fuel/hour of when the order was places
              Readln(tFile, Sline) ;
                // Calculate the hours that the flight will last
              rHours  := (tblOrders['E/D Date'] - tblOrders['Pickup Date']) * 24 ; // Get the difference in time and convert it to hours
              rRevenue := rRevenue + StrToFloat(sLine)   * rHours  ; // times by the hours of the flight
                 if (YearOF(tblOrders['Pickup Date']) = YearOf(Date))  then  // increase the revenue that was made this year only
             rYearlyRevenueGoal := rYearlyRevenueGoal +  StrToFloat(sLine)   * rHours  ;

           CloseFile(tFile);
        end;

      end;
      tblOrders.Next ;
   end;
   lblTotalRevenue.Caption := 'Total Revenue: ' + FloatToStrF(rRevenue , ffCurrency ,10,2)  ;

   // Average Order Weight
    qrySQL.SQL.Text := 'Select AVG(Weight) as Result from tblOrders'  ;
   qrySQL.Open ;
   lblAverageWeight.Caption := 'Average Order Weight: ' + floattostrf((qrySQL['Result']), ffFixed, 10,2) + ' kg';

  // Set the progress bars for the yearly goals

  // For revenue goal
  PBrevenue.Min := 0;
  PBrevenue.Max := 100;
PBrevenue.Position := Floor(rYearlyRevenueGoal / RevenueGoal* 100 ) ;
  // For the order goal
  PBOrders.Min := 0 ;
  PBOrders.Max := 100;
PBOrders.Position := Floor(iYearlyOrdersGoal / OrdersGoal *100);
end;

procedure TfrmVolitant_Express.btnRestartVidClick(Sender: TObject);
begin
// Restart the video if it played fully or go to the beginnign of the video at any time
mpIntroVideo.Stop;     // Stop the video
mpIntroVideo.Position := 0; // Sets the video's time to the begining
mpIntroVideo.Play;     // Restart the video
end;

procedure TfrmVolitant_Express.btnSearcCompAgeRangeClick(Sender: TObject);
var
  iAge, iCount : integer ;
  sGovernment : string;
begin
// Search for companies in an age range
  // Validation
  if sedAgeTopSearch.Value < sedAgeBottomSearch.Value then
  begin
    ShowMessage('Upper year may not be lower than lower year');
    exit;
  end;
  iAge := 0;

  redCompanyOut.Clear ;
     // Set the tabstops
     redCompanyOut.SelAttributes.Color := clRed;
     redCompanyOut.Paragraph.TabCount := 5;
     redCompanyOut.Paragraph.Tab[0] := 75;
     redCompanyOut.Paragraph.Tab[1] := 225;
     redCompanyOut.Paragraph.Tab[2] := 375;
     redCompanyOut.Paragraph.Tab[3] := 445;
     redCompanyOut.Paragraph.Tab[4] := 560;
    redCompanyOut.Lines.Add('CompanyID'+ #9+ 'Company Name'+ #9+'LocationBased'+#9+ 'Government'+ #9+'Company Age(Years)'+ #9+ 'Total Orders'+ #13) ;
  tblCompany.First ;
  while not tblCompany.eof do
  begin
    iAge := YearsBetween(Date, tblCompany['Establishment Date']);

    if (  iAge >= sedAgeBottomSearch.Value) and (  iAge <= sedAgeTopSearch.Value)  then // Companies in the age range
    begin
      iCount := 0;
      tblOrders.First ;
      while not tblOrders.Eof do    // Count the orders that the company has made
      begin
        if tblCompany['CompanyID'] = tblOrders['CompanyID'] then  // Where the company has an order
        begin
          Inc(iCount)  ;
        end;

        tblOrders.Next ;
      end;
      // Set the government variable
      if tblCompany['Goverment Agency'] = true then
      sGovernment := 'Yes'
      else
      sGovernment := 'No';
      // Display the company info
      redCompanyOut.Lines.Add(IntToStr(tblCompany['CompanyID']) + #9 + tblCompany['CompanyName']+ #9+ tblCompany['Location Based']+#9+sGovernment  +#9+ IntToStr(iAge)+#9+IntToStr(iCount)) ;
    end;
    tblCompany.Next ;
  end;
end;

procedure TfrmVolitant_Express.btnSearchForOrdersClick(Sender: TObject);
var
  bNothing, bID, bName, bCompFound, bOrdersFound : boolean ;
  sNameSearch : string ;
  iIDsearch, iRecordNumKeep : integer ;
begin
// Display all orders to edit, depending on input criteria
  lstSelectOrderAdmin.Clear ;
bNothing := True;     // If none of the below conditions are met, display all editable orders
  // Determine the type of search for orders  by the admin
  if sedEnterCNameSearchOrderUpdate.Value > 0 then // Check if an ID was entered
  begin
    bNothing := False ;
    bID := True;
    iIDsearch :=  sedEnterCNameSearchOrderUpdate.Value;
  end
  else
  if not (edtCompanyNameSearchOrders.Text = '') then // Check if a name was entered, if an ID was not entered
  begin
    bNothing := False;
    bName := True ;
    sNameSearch :=  edtCompanyNameSearchOrders.Text;
    // Get the ID of the company to be used
    tblCompany.First ;
    bCompFound := False ;
    while not tblCompany.Eof and (bCompFound = FAlse) do // Search for a matching company
    begin
      if (UpperCase(sNameSearch ) = UpperCase(tblCompany['CompanyName']))  or (UpperCase(sNameSearch ) = UpperCase(tblCompany['Username']))  then // If a matching company is found based on username or CompanyName
      begin
        bCompFound := True ;
        iIDsearch := tblCompany['CompanyID']
      end;
      tblCompany.Next ;
    end;
    if bCompFound = False then  // if no matching company was found
    begin
      ShowMessage('No matching Company found based on the input provided') ;
      exit;
    end;
  end
  else
  if sedSearchByOrderID.Value > 0 then // If an OrderID was entered
  begin
  
  end;
  

  // find matching orders on the company
    tblOrders.First ;
    bOrdersFound := False ;
    while not tblOrders.Eof  do    // exlude orders that has been CANCELLED OR DELIVERED
    begin
       // To do if Nothing was entered- Show all orders that can be edded
       if (bNothing = True) and (tblOrders['Status'] <> 'Delivered') and (tblOrders['Status'] <> 'Canceled'){(tblOrders['Status'] in ['Delivered', 'Canceled'])} then  // Turns out ID is only usable for Ordinal types
       begin
         bOrdersFound := True;
         iRecordNumKeep := tblOrders.RecNo ;// I must store the record, as I loop thru the db in the function, in order keep going from where I was in the process
         lstSelectOrderAdmin.Items.Add(IntToStr(tblOrders['OrderID']) +'--'+ tblOrders['Pickup Country'] + ' -TO- ' + tblOrders['Drop of Country'] + ' -- '+ tblOrders['Status']+ ' - ' +FloatToStrF(CalcOrderPrice(tblOrders['OrderID']), ffCurrency , 10,2 ) )  ;   // Add item to the lst box
         tblOrders.RecNo := iRecordNumKeep ;// Set pointer where be were before calling the function
       end
       else  // If something was entered
       if ((bID = True) or (bName = True)) and (tblOrders['CompanyID'] = iIDsearch)and not (tblOrders['Status'] = 'Delivered') and not (tblOrders['Status'] = 'Canceled') then  // If a companyID was entered or after the CompanyID was located from the database based on the Name entered
       begin
          bOrdersFound := True;
          iRecordNumKeep := tblOrders.RecNo ;// I must store the record, as I loop thru the db in the function, in order keep going from where I was in the process
        lstSelectOrderAdmin.Items.Add(IntToStr(tblOrders['OrderID']) +'--'+ tblOrders['Pickup Country'] + ' -TO- ' + tblOrders['Drop of Country'] + ' -- '+ tblOrders['Status']+ ' - ' +FloatToStrF(CalcOrderPrice(tblOrders['OrderID']), ffCurrency , 10,2 ) )  ;   // Add item to the lst box
         tblOrders.RecNo := iRecordNumKeep ;// Set pointer where be were before calling the function
       end;
      tblOrders.Next ;
    end;

    if not bOrdersFound  then // Tell admin if no orders were found that were valid
    begin
      ShowMessage('No orders matching the Criteria/ Input found to manage!') ;
    end;
end;

procedure TfrmVolitant_Express.btnSeatchForCompanyClick(Sender: TObject);
var
  iOrderCount : integer;
  sGovernment : string ;
begin
// Search for a company based on the company name
  // Set the tab stops
    redCompanyOut.Clear ;
     redCompanyOut.SelAttributes.Color := clRed;
     redCompanyOut.Paragraph.TabCount := 4;
     redCompanyOut.Paragraph.Tab[0] := 75;
     redCompanyOut.Paragraph.Tab[1] := 225;
     redCompanyOut.Paragraph.Tab[2] := 375;
     redCompanyOut.Paragraph.Tab[3] := 445;
     redCompanyOut.Lines.Add('CompanyID'+ #9+ 'Company Name'+ #9+'LocationBased'+#9+ 'Government'+ #9+ 'Total Orders'+ #13) ;

     redCompanyOut.SelAttributes.Color := clBlack ;
  tblCompany.First ;
  while not tblCompany.eof do
  begin
     if Pos(UpperCase(edtEnterSearchCompany.Text), UpperCase(tblCompany['CompanyName'])  )> 0  then   // Find names that matches what was entered in the edit
     begin
        iOrderCount := 0 ;
        // Count orders that the company has placed
        tblOrders.First ;
        while not tblOrders.eof do
        begin
            // Finder orders under the company
            if tblCompany['CompanyID'] = tblOrders['CompanyID'] then
            Inc(iOrderCount);

          tblOrders.Next ;
        end;
           // Get government agency string
        if tblCompany['Goverment Agency'] =True then
        sGovernment := 'Yes'
        else
        sGovernment := 'No';

        redCompanyOut.Lines.Add(IntToStr(tblCompany['CompanyID']) +#9+ tblCompany['CompanyName']+#9+ tblCompany['Location Based']+#9+sGovernment+#9+IntToStr(iOrderCount) ) ;
     end;

    tblCompany.Next ;
  end;

end;

procedure TfrmVolitant_Express.btnTopPickupCClick(Sender: TObject);
begin
// Get the Pickup Counties that are used more than once, and which orders are not cancelled and have been paid
qryGrid.SQL.Text :='Select [Pickup Country], Count(*) as [Times Picked Up] from tblOrders where not (Status = "Canceled") and (Paid = True) Group By [Pickup Country] Having Count(*) > 1';
qryGrid.Open ;
end;

procedure TfrmVolitant_Express.btnSendNewsletterClick(Sender: TObject);
begin
// Send the newsletter
end;

procedure TfrmVolitant_Express.btnSortCompanyTableClick(Sender: TObject);
begin
// Sort the company table by name
tblCompany.Sort := 'CompanyName' ;
end;

procedure TfrmVolitant_Express.btnGroupOrdersByStatusClick(Sender: TObject);
begin
// Show all of the orders in the database and group them accrding to status
qryGrid.SQL.Text := 'Select OrderID, Status from tblOrders Group By Status, OrderID Order By Status DESC'  ;
qryGrid.Open ;
end;

procedure TfrmVolitant_Express.btnToAdminManageClick(Sender: TObject);
begin
// Go to the manage admins page from any of the other admin pages
pgcAdmin.ActivePage.TabVisible := False;
tblAdmins.First ;// Go to the first admin account in the tabel
dbgAdminsCellClick(dbgAdmins.Columns[0]) ;
tsAdminManage.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnToCompaniesClick(Sender: TObject);
begin
// Go to the company admin manage page from any of the other admin pages
pgcAdmin.ActivePage.TabVisible := False;
tsCompaniesAdmin.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnToCustomClick(Sender: TObject);
var
  sCustomPagePass : string;
begin
// Go to the custom SQL page, ask for a special password to gain access to this part of the website
   pgcAdmin.ActivePage.TabVisible := False;
    qrySQL.Close ;  // Remove anythign that might be in the DBG grid from another use
   tsCustomAdmin.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnToEmailsClick(Sender: TObject);
begin
// Go to the admin email page from any of the other pages
pgcAdmin.ActivePage.TabVisible := False;
tsEmailsAdmin.TabVisible := True;
end;

procedure TfrmVolitant_Express.btnToGridClick(Sender: TObject);
begin
// Go to the admin grid tab page
  pgcAdmin.ActivePage.TabVisible := False;
  tsGrid.TabVisible := True;
  qryGrid.Close ; // Remove anythign that might be in the DBG grid from another use
end;

procedure TfrmVolitant_Express.btnToItemsClick(Sender: TObject);
begin
 // Go to the Items page from any of the other pages
 pgcAdmin.ActivePage.TabVisible := False;
 tsItemsAdmin.TabVisible := True;

   if not FileExists('Item_Categories.txt')  then  // Check that the categories file does exist
  begin
    ShowMessage('Item_Categories.txt not Found. Add categories to resolve this problem');
    Exit;
  end;
  // Load the different categories into the combo box
 cmbItemCategoryAdd.Items.LoadFromFile('Item_Categories.txt') ;

 // Load a list of all the items into the list box to update them
 lstSelectItemManage.Clear;

 tblItems.First ;
 while not tblItems.eof do
 begin
      // Load item into the list box
    lstSelectItemManage.Items.Add(tblItems['Item Name'] + ' -- '+ tblItems['Category']+ ' -- '+floattostrf(tblItems['T_Cost/kg'], ffCurrency,10,2));
  tblItems.Next ;
 end;
 iItemUpdateID := 0 ;


   // clear update inputs
  edtSearchForItem.Clear ;
  sedUpdateItemRands.Value := 0;
  sedUpdateItemCents.Value := 0;
  chkChangeItemDangerous.Checked := False;
  redUpdateItem.Clear ;
  lstSelectItemManage.ItemIndex := -1;

  // Disable the company management buttons
  btnDeleteCompanyAdmin.Enabled := False;
  chkSuspendAccount.Enabled := False;

end;

procedure TfrmVolitant_Express.btnTOhistoryClick(Sender: TObject);
begin
// Go to the page to order history page from the home page
tsHome.TabVisible := False;
tsHistory.TabVisible := True ;
end;

procedure TfrmVolitant_Express.btnTOorderClick(Sender: TObject);
var
  I, iHeighest, iDefaultHours : integer ;
  tFile : textfile;
  sLine : string ;
  dtSetDefaultDateTimeOfPickup : TDateTime ;
begin
// Go to the page to place an order for a transport from the home page

  // Load the info into the Place order page componets
    // Load the countries into the combo boxes  for the Pickup/ Drop Country
    cmbSelectPickupCountry.Clear ; // Clears any txt that may have been in the comboBox
    cmbSelectDropOffCountry.Clear ;
    for I := 1 to iCountryCount do
    begin // Load the countries into the comvbo boxes
      cmbSelectPickupCountry.Items.Add(arrCountryName[i]) ;
      cmbSelectDropOffCountry.Items.Add(arrCountryName[i]) ;
    end;
    // Load categories into the combobox
  if not FileExists('Item_Categories.txt')  then  // Check that the file exists
  begin // If not, create the file
      AssignFile(tFile, 'Item_Categories.txt');
    Rewrite(Tfile)  ;
   CloseFile(tFile);
  end
  else
  begin
    // Read categories from txt file into combobox, if the file does exis
    AssignFile(tFile, 'Item_Categories.txt');
    Reset(tFile);
    while not Eof(tFile)  do
    begin
      Readln(tFile, sLine);
      cmbCategory.Items.Add(sLine) ;
    end;
    CloseFile(tFile);
  end;
  cmbCategory.ItemIndex := 0 ; // Set it to all

    // Load the items into the listbox
    lstSelectTransportItem.Clear ;
  tblItems.First ;
  while not tblItems.eof do
  begin
    if (tblItems['Retired'] = False) then // If the user wants to see all of the items from tall of the category
    begin
       lstSelectTransportItem.Items.Add(tblItems['Item Name']) ;
    end;
    tblItems.Next ;
  end;

    // Set the max weight that a order can be based on the current active planes
    // Find the active plain with the max load
    tblPlanes.First ;
    iHeighest := 1;
    while not tblPlanes.eof do
    begin
      if (tblPlanes['Max Load'] > iHeighest) and (tblPlanes['Retired'] = False) then // If a larger max load is found
      iHeighest := Floor(tblPlanes['Max Load']) ;
    tblPlanes.Next ;
    end;
    sedAddOrderKg.MaxValue := iHeighest -1; // Minus one to account for cents and stuff

    // Get the distance for the order





  //  Set pickup date time compoemts to default hours from now
    // Get the defualt hours if the company
    iDefaultHours := 0 ;
    qrySQL.SQL.Text := 'Select [Defualt Hours] as Result from tblCompany where CompanyID = '+ IntToStr(iID);
    qrySQL.Open ;
    iDefaultHours := qrySQL['Result'] ;
    dtSetDefaultDateTimeOfPickup := Now + (iDefaultHours / 24);
    // Update the Date  and time in the componets
    dtpChoosePickupDate.Date := Trunc(dtSetDefaultDateTimeOfPickup)  ;// Set the date and convert default hours part to days
    tpChoosePickupTime.Time := Frac(dtSetDefaultDateTimeOfPickup) ;



tsHome.TabVisible := False;
tsPOrder.TabVisible := True ;
tsOrderSummary.TabVisible := False;
end;

procedure TfrmVolitant_Express.btnToOrdersClick(Sender: TObject);
begin
// Go the the orders admin page from any other of the admin pages
 pgcAdmin.ActivePage.TabVisible := FAlse;
 tsOrdersAdmin.TabVisible := true ;
 redOrderOut.Font.Size := 9;
end;

procedure TfrmVolitant_Express.btnToOrdersOutputClick(Sender: TObject);
begin
// Go to the orders output page from the orders update page
pgcAdminOrders.ActivePage := tsOrderOutput;
end;

procedure TfrmVolitant_Express.btnTOorderUpdateClick(Sender: TObject);
begin
// Go to the update orders page from the order output page
pgcAdminOrders.ActivePage := tsOrderUpdate ;
end;

procedure TfrmVolitant_Express.btnTOpaymentClick(Sender: TObject);
var
  bPayFound, bItemFound : boolean;
  sItemName : string ;
begin
// Go to the page to manage payments page from the home page
  lstPayment.Clear ;
  // Load all payable orders into the list box
  tblOrders.First ;
  bPayFound := False;
  bItemFound := false;
  sItemName := '';
  while not tblOrders.Eof do  // Search for orders
  begin
    if tblOrders['CompanyID'] = iID then // Order made by the specific company
    begin
      if (tblOrders['Paid'] = False) and not (tblOrders['Status'] = 'Canceled') then // If the order has not been paid and the order has not been cancelled
      begin
        bPayFound := True;
        // Get the item name of the order
        tblItems.First ;
        while not tblItems.Eof and (bItemFound = false) do // Loop thru item table to find the item in the order
        begin
          if tblItems['itemID'] = tblOrders['ItemID'] then // If a matching order is found
          begin
            bItemFound := True ;
            sItemName := tblItems['Item Name'];
          end;

          tblItems.Next ;
        end;
        lstPayment.Items.Add('OrderID: '+ IntToStr(tblOrders['OrderID'])+ ' --Item: '+ sItemName+ ' --TotalCost: ' + FloatToStrF(CalcOrderPrice(tblOrders['OrderID']), ffCurrency, 10,2 ) + ' --FROM ' + tblOrders['Pickup Country'] + ' -TO- ' + tblOrders['Drop of Country'] ) ;
      end;
    end;
    tblOrders.Next ;
  end;

tsHome.TabVisible := False;
tsPayment.TabVisible := True ;
redPaymentConfirm.Clear ;
  if not bPayFound then  //  display a message if no payments to be made were found
  ShowMessage('Lucky you, all your order are paid, or, unlucky us; youve not made an order yet :)') ;
end;

procedure TfrmVolitant_Express.btnToPlanesClick(Sender: TObject);
begin
// Change the active admin page to Plane management
pgcAdmin.ActivePage.TabVisible := False;
tsPlanesAdmin.TabVisible := True ;
  // Load the manage plane list box
  tblPlanes.First ;
  while not tblPlanes.eof do
  begin         // Load into a list box
    lstManagePlane.Items.Add(IntToStr(tblPlanes['PlaneID']) +'-'+tblPlanes['Plane Name']+' -- '+ FloatToStrF(tblPlanes['FuelCost'], ffCurrency ,10,2)  );
    tblPlanes.Next ;
  end;
  lstManagePlane.ItemIndex := -1 ;

end;

procedure TfrmVolitant_Express.btnToSummaryClick(Sender: TObject);
begin
// Go to the summary page and load the info on the page
  pgcAdmin.ActivePage.TabVisible := false;
  tsAdminSum.TabVisible := True;
  btnReloadSum.Click  ;
end;

procedure TfrmVolitant_Express.btnToThemeClick(Sender: TObject);
begin
// go the the theme change admin page from any other of the admin pages
   pgcAdmin.ActivePage.TabVisible := False;
   tsThemeAdmin.TabVisible := True;
  // Set the color themes of all the components
  clbWelcomeLabelTheme.Selected := lblWelcome.Font.Color ;
  clbLoginLabel.Selected := lblLogin.Font.Color ;
  clbUpdateOrdersLabelTheme.Selected := lblOrder.Font.Color ;
end;

procedure TfrmVolitant_Express.btnUpdateItemClick(Sender: TObject);
var
  bFound : boolean ;
begin
// Update the item

// Validation
    // Ensure that item was selected to update
  if lstSelectItemManage.ItemIndex = -1 then
  begin
    ShowMessage('Select item to manage') ;
    exit ;
  end;
  if sedUpdateItemRands.Value = 0 then // Emsure that item transport price was entered
  begin
    ShowMessage('Enter an amount of money for the item') ;
    exit;
  end;
    // Ensure that the note of the item is in range
  if Length(redUpdateItem.Text) > 120 then
  begin
    ShowMessage('Item Note may not be longer than 120 chracters');
    exit;
  end;

    // Update the item
    tblItems.First ;
    bFound := false;
    while not tblItems.eof and (bFound = False) do
    begin
      if iItemUpdateID = tblItems['ItemID'] then  // if a matching item is found
      begin
        bFound := True ;
          tblItems.Edit ;
        tblItems['T_Cost/kg'] := sedUpdateItemRands.Value + (sedUpdateItemCents.Value / 100);
        tblItems['Dangerous'] := chkChangeItemDangerous.Checked ;
        tblItems['Note'] := redUpdateItem.Text ;
        // Update the retire item part
        if  btnRetireItem.Caption = 'Retire Item' then
        begin
          tblItems['Retired'] := False;
        end
        else
        begin
           tblItems['Retired'] := True;
        end;

        tblItems.Post ;
        // Update the listbox
        lstSelectItemManage.Items[lstSelectItemManage.ItemIndex] := tblItems['Item Name'] + ' -- '+ tblItems['Category']+ ' -- '+floattostrf(tblItems['T_Cost/kg'], ffCurrency,10,2) ;

      end
      else
    tblItems.Next ;
    end;

  // clear update inputs
  edtSearchForItem.Clear ;
  sedUpdateItemRands.Value := 0;
  sedUpdateItemCents.Value := 0;
  chkChangeItemDangerous.Checked := False;
  redUpdateItem.Clear ;
  lstSelectItemManage.ItemIndex := -1;

  ShowMessage('Item updated successfully') ;
end;

procedure TfrmVolitant_Express.btnUpdateLoginLabelThemeClick(Sender: TObject);
begin
// Update the Login lable color theme
  lblLogin.font.Color := clbLoginLabel.Selected;
  WriteToFormTheme('Themes/Login_label_theme.txt', clbLoginLabel.Selected) ;
  ShowMessage('Login label theme updated');
end;

procedure TfrmVolitant_Express.btnUpdateOrderLabelThemeClick(Sender: TObject);
begin
// Update the ORders lable color theme
  lblOrder.font.Color := clbUpdateOrdersLabelTheme.Selected;
  WriteToFormTheme('Themes/Order_label_theme.txt', clbUpdateOrdersLabelTheme.Selected) ;
  ShowMessage('Orders label theme updated');
end;

procedure TfrmVolitant_Express.btnUpdateOrderStatusClick(Sender: TObject);
var
  dtPickup, dtEDDropoff : TDateTime ;
  iOrderID : integer ;
  bOrderFound, bCompanyFound : boolean ;
  sUpdatedStatus, sEmail : string;
  rTripLength : real;
begin
// Commit order update as an Admin
  sEmail := '';
  // Validation
    // Ensure that order to manage was selected
      if lstSelectOrderAdmin.ItemIndex = -1 then
      begin
        ShowMessage('Please select an order to manage')  ;
        exit;
      end;
      // Ensure than a status is selected
    if rgpOrderStatus.ItemIndex = -1 then
    begin
      ShowMessage('Ensure that a status has been selected') ;
      exit ;
    end;
    // Ensure that updated date is in the future, exepst if order is being changed to Canceled
      sUpdatedStatus := rgpOrderStatus.Items[rgpOrderStatus.ItemIndex] ; // Get the New status
    dtPickup := dpUpdatePickupDate.Date + tpUpdatePickupTime.Time ; // Create the time variable
    if not (dtPickup > Now) and not (sUpdatedStatus = 'Canceled') then
    begin
      ShowMessage('Updated Date and Time must be in the future') ;
      exit;
    end;
  // Get the order ID
  iOrderID := strtoint(Copy(lstSelectOrderAdmin.Items[lstSelectOrderAdmin.ItemIndex], 1, Pos('--', lstSelectOrderAdmin.Items[lstSelectOrderAdmin.ItemIndex])-1));
  bOrderFound := False ;

  tblOrders.first;
  while not tblOrders.Eof and (bOrderFound = false) do // Search for the order to update
  begin
    if tblOrders['OrderID'] = iOrderID then // Find a matching orders
    begin
      bOrderFound := True;
      // Prevent certain status changes
        // Prevent In transit To Canceled
        if (tblOrders['Status'] = 'In Transit') and (sUpdatedStatus = 'Canceled') then
        begin
          ShowMessage('You are not allowed to change the order status from In Transit TO Canceled');
          SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
          exit;
        end;
        // Prevent any other status change that goes to Delivered if it is not In Transit
        if (sUpdatedStatus = 'Delivered') and not (tblOrders['Status'] = 'In Transit') then
        begin
          ShowMessage('A orders status can only be changed to Delivered from a In Transit Status') ;
            SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
          exit;
        end;
        // Only allow an order to be put into transit from the Waiting for pickup status
        if (sUpdatedStatus = 'In Transit') and not (tblOrders['Status'] = 'Waiting for Pickup') and not (tblOrders['Status'] = 'In Transit') then
        begin
            ShowMessage('A orders status can only be changed to an In Transit Status from a Wating for Pickup Status') ;
            SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
          exit;
        end;
        // Only allow certain functions if a company, say has paid  for the order
        if (tblOrders['Paid'] = False) and (sUpdatedStatus = 'In Transit')  then
        begin
          ShowMessage('An order can''t be put into transit if it has not been payed');
            SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
          exit;
        end;
        // Ensure that if a new time is entered, that it is more than a day away from the current date and time
        if not (tblOrders['Pickup Date'] = dtPickup) then
        begin
          if ((dtPickup - Now) <= 1) {and not (sUpdatedStatus = 'Canceled')} then
          begin
            ShowMessage('New date should be more than a day away from the current date');
              SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
            exit;
          end;
        end;
       // Ensure that the status is not changed to Waiting for Pickup unless from Delayed
       if (sUpdatedStatus = 'Waiting for Pickup') and not (tblOrders['Status'] = 'Delayed') and not (tblOrders['Status'] = 'Waiting for Pickup') then
       begin
         ShowMessage('You can''t give an order a ''Waiting for Pickup'' status if it is in any other status than the ''Delayed'' status');
           SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
         exit;
       end;
      // Ensure that account is not suspended- suspended account will not be allowed to have orders changed from waiting to pickup or Delayed to In Transit
      bCompanyFound := False;
      tblCompany.First ;
      while not tblCompany.Eof and (bCompanyFound = False) do // Search for the company of the order
      begin
        if tblCompany['CompanyID'] = tblOrders['CompanyID'] then  // if a matching company is found
        begin
          bCompanyFound := True;
           sEmail := tblCompany['Email'] ;// Get the companies email
            // If an in transit order is changed to delayed, ensure that a new date in the furure, at least a week away is selected
           if (sUpdatedStatus = 'Delayed') and (tblOrders['Status'] = 'In Transit') then
           begin
             // Ensure that a new date for the order is selected, more than 7 days away  \
              if ((dtPickup - Now) <= 7) then
              begin
                ShowMessage('New date for the order should be more than a week away from the current date');
                  SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
                exit;
              end;
             SendEmail(tblCompany['Email'], 'Order with ID ' + IntToStr(iOrderID) + 'has been delayed while in transit.'+#13+' A new PICKUP DATE has been set to '+DateTimeToStr(dtPickup) +#13+'. Login to manage the order and put it in the ''Waiting for delivery stage''' );
           end;

          if tblCompany['suspended'] = True then   // if the company is suspended
          begin
            if (tblOrders['Status'] = 'Waiting for Pickup') and (sUpdatedStatus = 'In Transit') then  // A suspended companies many not put orders into transit
            begin
                ShowMessage('Suspended account order may not be put into transit'+ #13+'Recommended: Change order to Delayed');
                  SetOrderStatusItemIndex(tblOrders['Status']); // Set the order status radio group tp the right itemIndex
                exit;
            end;
          end;
        end;
        tblCompany.Next ;
      end;
      // Update the order
        // Calculate the E/D date
        rTripLength := (tblOrders['Distance'] / GetPlainCruisingSpeed(tblOrders['PlaneID']) / 24) ; // Get the trip length in hours and theravter convert it to days
        dtEDDropoff := dtPickup + rTripLength ;
        // Write the updated order to the db
        tblOrders.Edit;

          // Refund the money of the order if the user has paid for it in the past
         if (sUpdatedStatus = 'Canceled') and not (tblOrders['Status'] = 'Canceled') and (tblOrders['Paid'] = True) then
         begin
          tblOrders['Paid'] := False;
          ShowMessage('Company has been refunded for the Now Canceled order');
          SendEmail(sEmail, 'Your order with ID '+ IntToStr(tblOrders['OrderID']) + ' has been canceled. The money you paid has been refunded' ) ;
         end;
         tblOrders['Pickup Date'] := dtPickup ;
        tblOrders['E/D Date'] := dtEDDropoff ;
        tblOrders['Status'] := sUpdatedStatus ;

        tblOrders.Post ;
      // Remove order from lst box if its status is set to Cancelled or Delivered as it can not longer be updated thereafter
      if (sUpdatedStatus = 'Canceled') or (sUpdatedStatus = 'Delivered') then
      begin
        lstSelectOrderAdmin.Items.Delete(lstSelectOrderAdmin.ItemIndex) ;// Delete the item in the list box
      end
      else
      begin // if any other status then update the list box to show the new status
        lstSelectOrderAdmin.Items[lstSelectOrderAdmin.ItemIndex] := IntToStr(tblOrders['OrderID']) +'--'+ tblOrders['Pickup Country'] + ' -TO- ' + tblOrders['Drop of Country'] + ' -- '+ tblOrders['Status']+ ' - ' +FloatToStrF(CalcOrderPrice(tblOrders['OrderID']), ffCurrency , 10,2 );
      end;
      // Clear compoents
      rgpOrderStatus.ItemIndex := -1;
      dpUpdatePickupDate.Date := Today ;
      tpUpdatePickupTime.Time := Time;


      ShowMessage('Order Updated Successfully!');
    end;
      tblOrders.next;
  end;

end;

procedure TfrmVolitant_Express.btnUpdatePlaneClick(Sender: TObject);
var
  iPlaneID, iPlainUseCount : integer;
  bFound : boolean ;
begin
// Update the plane info

  // Validation
    // Validate that plane is selected
    if lstManagePlane.ItemIndex = -1 then
    begin
      ShowMessage('Select a plane to update');
      exit;
    end;
    // Validate that a fuel price was entered
    if sedUpdateFuelRands.Value = 0  then
    begin
      ShowMessage('Enter a fuel price for the Plane') ;
      exit;
    end;
      // Get the planeID
    iPlaneID  := StrToInt(Copy(lstManagePlane.Items[lstManagePlane.ItemIndex], 1, Pos('-',lstManagePlane.Items[lstManagePlane.ItemIndex])-1 ) ) ;
    {
    // Ensure that the amount of plains after the plain count update, is not less than the amount of plains being used in orders currently
    iPlainUseCount := 0 ;
    tblOrders.First ;
    while not tblOrders.Eof do
    begin
         if tblOrders['PlaneID'] = iPlaneID then // If a matching order was found
         begin
          if not (tblOrders['Status'] = 'Delivered') and not (tblOrders['Status']= 'Canceled') then  // If the plain is still being used, inc the amount of plains beign used counter
          begin
            Inc(iPlainUseCount) ;
          end;
         end;
      tblOrders.Next ;
    end;
      // Check that enough planes will be left overs
      if iPlainUseCount > sedUpdatePlaneCount.Value then
      begin
        ShowMessage('Not enough planes left for amount used in active orders'+#13+'Wait untill all orders are handeled before lowering the coount'+#13+ 'Retire plain temporarly to prevent more orders from beign added to plain. Update plain count after all orders using it was handeled and then unretire plain');
        exit; 
      end;       }
    // update the plane
      bFound := false;
      tblPlanes.First ;
      while not tblPlanes.Eof and (bFound = False) do
      begin
        if tblPlanes['PlaneID'] = iPlaneID then // If a matching record was found
        begin
          bFound := True;
          // Update the plane
          tblPlanes.Edit ;
          tblPlanes['Retired'] := chkRetirePlane.Checked ;
          tblPlanes['FuelCost'] := sedUpdateFuelRands.Value + sedUpdateFuelCents.Value / 100;
         { tblPlanes['Count']:= sedUpdatePlaneCount.Value ; }
          tblPlanes.Post ;
           // Update the listbox
          lstManagePlane.Items[lstManagePlane.ItemIndex] := IntToStr(tblPlanes['PlaneID']) +'-'+tblPlanes['Plane Name']+' -- '+ FloatToStrF(tblPlanes['FuelCost'], ffCurrency ,10,2)  ;
        end
        else
        tblPlanes.Next ;
      end;

    // Clear inputs
    chkRetirePlane.Checked := False;
    sedUpdateFuelRands.Value := 0;
    sedUpdateFuelCents.Value := 0;
   { sedUpdatePlaneCount.Value := 1 ;}
    lstManagePlane.ItemIndex := -1;
    // Confirmation if successfull
    ShowMessage('Plane updated successfully') ;
end;

procedure TfrmVolitant_Express.btnUpdateSuspensionClick(Sender: TObject);
var
  bSuspended : boolean;
  sSuspended : string;
begin
// Read the suspension update to the database
  // Set boolean var for db updation
  if chkSuspendAccount.Checked then
  begin
    bSuspended := True;
    sSuspended := 'Yes' ;
  end
  else
  begin
    bSuspended := False;
    sSuspended := 'No';
  end;

  // Update the suspension
  qrySQL.SQL.Text := 'Update tblCompany Set Suspended = ' + booltostr(bSuspended) + ' where CompanyID = ' + IntToStr(sedEnterCompanyID.Value)   ;
  qrySQL.ExecSQL ;
  // Update the last line in the richedit containign info about the companies suspension

  redCompanyOut.Lines[redCompanyOut.Lines.Count - 1] := 'Suspended: '+ sSuspended;    // Update the last line; last line will always be the suspended line

  ShowMessage('Updated suspension successfully');
end;

procedure TfrmVolitant_Express.btnUpdateWelcomeLabelClick(Sender: TObject);
begin
// Update the welcome lable color theme
  lblWelcome.font.Color := clbWelcomeLabelTheme.Selected;
  WriteToFormTheme('Themes/welcome_label_theme.txt', clbWelcomeLabelTheme.Selected) ;
  ShowMessage('Welcome label theme updated');
end;

procedure TfrmVolitant_Express.Button1Click(Sender: TObject);
var
  rBaseCost : real;
   sPrevent_Copy : string;
begin
iID := 7;

   qrySQL.SQL.Text := 'Select * from tblCompany where CompanyID = ' + IntToStr(iID)  ;  // Get the company details
  qrySQL.Open ;

  rBaseCost := CalcBaseCost(qrySQL['Goverment Agency'], qrySQL['Establishment Date']) ;

 // ShowMessage(FloatToStr(rBaseCost) )  ;

 sPrevent_Copy := Prevent_Duplication ;
       redOrderSummary.Lines.Add(Prevent_Duplication );
end;

procedure TfrmVolitant_Express.Button2Click(Sender: TObject);
begin
tblAdmins.Sort := 'Username DESC' ;
end;

procedure TfrmVolitant_Express.chkUserDeleteAcoountClick(Sender: TObject);
begin
// If delete account checkbox is clicked by a user
  if chkUserDeleteAcoount.Checked then
  ShowMessage('Press the Update Account button to finalize Deletion of your account.');
end;

procedure TfrmVolitant_Express.cmbCategoryChange(Sender: TObject);
begin
// Load the items into the list box when a category is selected
  lstSelectTransportItem.Clear ;
  // Load the items into the list box, based on the category input
  tblItems.First ;
  while not tblItems.eof do
  begin
    if (cmbCategory.Items[cmbCategory.ItemIndex] = 'All') and (tblItems['Retired'] = False) then // If the user wants to see all of the items from tall of the category
    begin
      lstSelectTransportItem.Items.Add(tblItems['Item Name']) ;
    end
    else
    if (tblItems['Category'] = cmbCategory.Items[cmbCategory.ItemIndex]) and (tblItems['Retired'] = False) then // If a category that matches the input is found
    begin
      lstSelectTransportItem.Items.Add(tblItems['Item Name']) ;
    end;
    tblItems.Next ;
  end;
end;

procedure TfrmVolitant_Express.cmbCountryBasedChange(Sender: TObject);
var
  sFileName, sCountryName : string;
  I: Integer;
begin
// Display the flag of the selected Based country in the image by the register component
  imgBasedFlag.Visible := True;
  if cmbCountryBased.ItemIndex >=0 then // Make sure than an option was selected
  begin
    sFileName := 'Flags/' + arrCountryCode[cmbCountryBased.ItemIndex+1] + '.jpg';  // Create the name of the file to open
    if FileExists(sFileName) then
    imgBasedFlag.Picture.LoadFromFile(sFileName) // Load the image
    else
    imgBasedFlag.Picture.LoadFromFile('Flags/Not_Found.jpg') ;    // If, for some reason, The file cannot be found, display not found
  end
  else
   imgBasedFlag.Picture.LoadFromFile('Flags/Not_Found.jpg') ; // If no valid images was selected
end;

procedure TfrmVolitant_Express.cmbSelectDropOffCountryChange(Sender: TObject);
var
sFileName, sCountryName : string;
begin
// Load the flag into the image component for the drop off country
    if cmbSelectDropOffCountry.ItemIndex >=0 then // Make sure than an option was selected
  begin
    sFileName := 'Flags/' + arrCountryCode[cmbSelectDropOffCountry.ItemIndex+1] + '.jpg';  // Create the name of the file to open
    if FileExists(sFileName) then
    imgDropOffCountry.Picture.LoadFromFile(sFileName) // Load the image
    else
    imgDropOffCountry.Picture.LoadFromFile('Flags/Drop_Off_Country.png') ;    // If, for some reason, The file cannot be found, display not found
  end
  else
  imgDropOffCountry.Picture.LoadFromFile('Flags/Drop_Off_Country.png') ; // If no valid images was selected
end;
procedure TfrmVolitant_Express.cmbSelectPickupCountryChange(Sender: TObject);
var
sFileName, sCountryName : string;
begin
// Load the flag into the image component for the pickup country
    if cmbSelectPickupCountry.ItemIndex >=0 then // Make sure than an option was selected
  begin
    sFileName := 'Flags/' + arrCountryCode[cmbSelectPickupCountry.ItemIndex+1] + '.jpg';  // Create the name of the file to open
    if FileExists(sFileName) then
    imgPickupCountry.Picture.LoadFromFile(sFileName) // Load the image
    else
    imgPickupCountry.Picture.LoadFromFile('Flags/Pickup_Country.png') ;    // If, for some reason, The file cannot be found, display not found
  end
  else
   imgPickupCountry.Picture.LoadFromFile('Flags/Pickup_Country.png') ; // If no valid images was selected
end;

procedure TfrmVolitant_Express.cmbSelectTableChange(Sender: TObject);
begin
// Change the table being displayed in dbgDifferentTable

  case cmbSelectTable.ItemIndex of             // Set a data source to be active in the table
  0: dbgDifferentTables.DataSource := dsrOrders ;
  1: dbgDifferentTables.DataSource := dsrPlanes ;
  2: dbgDifferentTables.DataSource := dsrCompany ;
  3: dbgDifferentTables.DataSource := dsrItems ;
  end;
  if dbgDifferentTables.DataSource = dsrCompany then    // Set the button to sort the company table by name
  btnSortCompanyTable.Enabled := True
  else
  btnSortCompanyTable.Enabled := False;

end;

procedure TfrmVolitant_Express.cmbUpdateCountryBasedChange(Sender: TObject);
var
  sFileName : string ;
begin
// Display the flag of the selected Based country in the image component by the update country based

  if cmbUpdateCountryBased.ItemIndex >=0 then // Make sure than an option was selected
  begin
    sFileName := 'Flags/' + arrCountryCode[cmbUpdateCountryBased.ItemIndex+1] + '.jpg';  // Create the name of the file to open
    if FileExists(sFileName) then
    imgUpdateCountryBased.Picture.LoadFromFile(sFileName) // Load the image
    else
    imgUpdateCountryBased.Picture.LoadFromFile('Flags/Not_Found.jpg') ;    // If, for some reason, The file cannot be found, display not found
  end
  else
  imgUpdateCountryBased.Picture.LoadFromFile('Flags/Not_Found.jpg') ; // If no valid images was selected

end;

function TfrmVolitant_Express.CalcBaseCost(pGovernment: boolean;
  pEstablishmentDate: TDate): real;
  var
    rBaseCost : real;
    I: Integer;
    bThirdWorld, bCompanyFound, bCountryFound : boolean;
    tFile : TextFile ;
    sLine : string;
begin
// Calc the base cost of an order. To a degree, base cost is used to empower economical groth and to support companies, especially in the startup process
  // the value calculated here is for the company at the time of placing the order, and cannot be changed in the future

  rBaseCost := 7520.49 ; // Set initual value of base cost

  if not pGovernment then // If the company is not a government company at the time of placing the order, lower the bace cost by 10%
  rBaseCost := rBaseCost * (91/100)
  else
  rBaseCost := rBaseCost * (111/100);  // If it is a government agency, up the price a bit
  // Affected by company Age
  if YearsBetween(Date, pEstablishmentDate) < 10  then // If the company is younger than 10 years, give it a discount, to empower it to grow
  rBaseCost := rBaseCost * (92/100);
  // Affected by country based. A third world country based, will result in a dicount to empower economic growth
    // Get the country code
      // Get the country based
      tblCompany.First ;
      bThirdWorld := false ;
      bCountryFound := False;
      bCompanyFound := FAlse;
      while not tblCompany.Eof and  (bCompanyFound =  False)  do // Search for the active company
      begin
        if tblCompany['CompanyID'] = iID then // If the current active company is found
        begin
          // Find the countryu based
          for I := 1 to iCountryCount do
          begin
            if Uppercase(arrCountryName[i]) = Uppercase(tblCompany['Location Based']) then // If a matching county is found
            begin
               // Check if that country is listed in the third world country txt file
               bCountryFound := True;
               AssignFile(tFile, 'third-world-countries-2025.txt') ;
               if not FileExists('third-world-countries-2025.txt')  then // If the file is not found, create it and move in with life
               begin
               Rewrite(tFile)  ;
               CloseFile(tFile) ;
           //    break;
               end
               else
               begin // If the file exists
                Reset(tFile) ;
                  while not Eof(tFile)  do
                  begin
                     Readln(tFile, slIne) ;
                     sLine := Copy(sLine, 1 , Pos(',', sLine)-1 ); // Only keep the counry code
                     if sLine = arrCountryCode[i] then   // If the country based is found in the txt file
                     begin
                       bThirdWorld := True ;
                    //   break;
                     end;
                  end;
                CloseFile(tFile) ;
               end;
            end;
            if not bCountryFound  then// If no country matching was found for some reason
            begin
               bThirdWorld := True ; // I set it to true, as this accoring has me as making the mistake a large possibility  and I don't want the company to be disadvantaged
            end;
          end;
          bCompanyFound := True ;
          //break; // Exit the while loop
        end;
       tblCompany.Next ;
      end;
      // Empower the third world country
      if bThirdWorld  then
      begin
        rBaseCost := rBaseCost * (9/10);
      end;

    Result := RoundTO(rBaseCost, -2) ; // return the base cost value
end;

function TfrmVolitant_Express.CalcOrderPrice(pOrderID: integer): real;
var
  bOrderFound, bItemFound, bPlaneFound : boolean;
  rRevenueCalc, rHours : real;
  tFile : textFile ;
  sItemPrice, sFuelPrice  : string ;
begin
  // Calculate the price of an order

    // Search for the Spesific order
    bOrderFound := False;
    rRevenueCalc := 0 ;
    tblOrders.First ;
    while not tblOrders.Eof and (bOrderFound = False) do
    begin
      if tblOrders['OrderID'] = pOrderID  then   // Find a matching order
      begin
         bOrderFound := True ;
         // Calculate Revenue
        rRevenueCalc := rRevenueCalc+ tblOrders['Base Cost'] ;// Set the base cost
          // Check that the file containing the prises of the order exists and contains valid info
          AssignFile(tFile, 'History_Log/'+ inttostr(tblOrders['OrderID'])+'.txt');
          if not FileExists('History_Log/'+ inttostr(tblOrders['OrderID'])+ '.txt' ) or ((tblOrders['Paid']= False ) and (YearsBetween(tblOrders['Pickup Date'], Date) > 1))  then  // If the file containing the prices was not found or the order pickup date is more than a year away- Rewrite the file and write the current prises to the file
          begin
            Rewrite(tFile) ;
            // Get the Current item prise
             bItemFound := False;
             tblItems.First ;
            while not tblItems.eof and (bItemFound = false) do // Loop thru items table to get the price for an item per kg
            begin
              if tblItems['ItemID'] = tblOrders['ItemID'] then // If a matcging item was found
              begin
                bItemFound := true;
                Writeln(tFile, FloatToStr(tblItems['T_Cost/kg']) ) ;  // Write the price of the item to the txt file
              end;

              tblItems.Next ;
            end;
            // Get the current price of the cost of fuel for that plane being used per hour
            bPlaneFound := False ;
             tblPlanes.First;
            while not tblPlanes.Eof and (bPlaneFound = false) do
            begin
               if tblPlanes['PlaneID'] = tblOrders['PlaneID'] then // if a maching plane was found
               begin
                  bPlaneFound := True;
                  Writeln(tFile, FloatToStr(tblPlanes['FuelCost']) );  // Write the price of the fuel to the txt file
               end;
              tblPlanes.Next ;
            end;
          end;
             Reset(TFile); // Prepare file for reading
       // Calc price of the item
          Readln(tFile,sItemPrice) ;
          rRevenueCalc := rRevenueCalc + StrToFloat(sItemPrice) * tblOrders['Weight'];
          // Calc the price of the fuel
          Readln(tFile, sFuelPrice );
           rHours  := (tblOrders['E/D Date'] - tblOrders['Pickup Date']) * 24 ; // Get the difference in time and convert it to hours
          rRevenueCalc := rRevenueCalc + StrToFloat(sFuelPrice) * rHours ;

          CloseFile(tFile) ;
      end;
      tblOrders.Next ;
    end;
    Result := rRevenueCalc ;
end;

procedure TfrmVolitant_Express.CGhomeThemeClick(Sender: TObject);
begin
// Change the theme of the home page
  // Change the color of the label
  lblWelcomeHome.font.Color := CGhomeTheme.ForegroundColor ;
   WriteToFormTheme('Themes/home_label_theme.txt',CGhomeTheme.ForegroundColor) ;
   // Change the theme of the group box
   grbHome.Color := CGhomeTheme.BackgroundColor ;
   WriteToFormTheme('Themes/home_grb_theme.txt', CGhomeTheme.BackgroundColor) ;

   ShowMessage('Theme of Home group box and label Updated')
end;

procedure TfrmVolitant_Express.chkAddAdminAccountClick(Sender: TObject);
begin
// Change the Captions and prepare and admin to be added if the Caption = a certain thing
end;

procedure TfrmVolitant_Express.dbgAdminsCellClick(Column: TColumn);
begin
// Load the admin account details when a cell is clicked
  // Load the username and password
  edtAdminUsername.Text := tblAdmins['Username'];
  edtAdminPassword.Text := tblAdmins['Password'];
  // Load the permissions of the selected record
  chkAdminChangeTheme.Checked := tblAdmins['Change_Theme'];
  chkAdminDeveloper.Checked := tblAdmins['Developer'] ;
  chkAdminManageAdmins.Checked := tblAdmins['Manage_Admins'];
  chkAdminNewsletter.Checked := tblAdmins['Newsletter']  ;
  chkAdminManagePlanes.Checked := tblAdmins['Plane_Manage'] ;
  chkAdminItemManage.Checked := tblAdmins['Item_Manage']  ;
end;

procedure TfrmVolitant_Express.dbgDifferentTablesCellClick(Column: TColumn);
begin
// If the active table is tblOrders: when a record is clicked on: Retrieve all the foreign data from the other tables and dispay info about that record in a showmessage
end;

function TfrmVolitant_Express.DeleteAccount(pID: integer): boolean;
begin   // Return if the deletetion was successfull
// Delete a company account
  if sedEnterCompanyID.Value = 54 then // Prevent delete accont holding from beign deleted
    begin
      ShowMessage('Deletion Holding Account cannot be deleted');
      Result := False;
      exit; 
    end;
    
  //Check that a company is deletable, by checking if there are any active/ unpaid orders
  tblOrders.First ;
  while not tblOrders.eof do
  begin
    if tblOrders['CompanyID'] = pID  then  // If the Order falls under the company that want to be deleted
    begin
      if (tblOrders['Paid'] = false) and not (tblOrders['Status'] = 'Canceled') then // Checks that there are no outstanding payments for orders which were not cancelled
      begin
         ShowMessage('Unpaid order(s) found.'+#13+ 'Pay order or Cancel order to delete account') ;
         Result := false;   // Return a false if the deletio failed
         exit;
      end;

      if not (tblOrders['Status'] = 'Delivered') and not (tblOrders['Status'] = 'Canceled') then // Check for orders that prevents deletion
      begin
        ShowMessage('Account Deletion not Eligible'+#13+'Active/Unresolved order(s) found.'+#13+'Resolve/ Complete orders to delete account.')  ;
        Result := False ;
        exit;
      end;

    end;

    tblOrders.next;
  end;

  // Move orders to deletion account, this is done to still keep the order data, and still allow for an account deletetion
  qrySQL.SQL.Text := 'Update tblOrders SET CompanyID = 54 where CompanyID = '+ inttostr(pID);
  qrySQL.ExecSQL ;

  // Delete the company account
  qrySQL.SQL.Text := 'Delete from tblCompany where CompanyID = '+ inttostr(pID);
  qrySQL.ExecSQL ;

  Result := True; // Return a True if the deletion was successfull
end;

procedure TfrmVolitant_Express.edtCompanyNameSearchOrdersClick(Sender: TObject);
begin
//Clear the spin edit used for searching for a company and orderID, as spinedit will be prioritized above Company name, thus should be cleared to prvent it
 sedEnterCNameSearchOrderUpdate.Value := 0 ;
 sedSearchByOrderID.Value := 0 ;
end;

procedure TfrmVolitant_Express.edtSearchForItemChange(Sender: TObject);
var
  I: Integer;
begin
// Search and select an item when you search for it
  for I := 0 to (lstSelectItemManage.Count-1) do
  begin
    if Pos(Uppercase(edtSearchForItem.Text), Uppercase(lstSelectItemManage.Items[i])) > 0  then  // Check for an item matching what is entered in the edit
    begin
      lstSelectItemManage.ItemIndex := i ;  // Set the index
       lstSelectItemManageClick(lstSelectItemManage);   // Call the lst box click
     //break;
    end;
  end;
end;

function TfrmVolitant_Express.FindPlane(pOrderWeight, pDistance : real; pPickupDateTime : TDateTime): integer;
var
  bPlaneFound, bValid : boolean;
  iRecordNumber, iPlaneCount : integer ;
  dtDropOffDateTime : TDateTime ;
  rHoursTripLength : real;
begin
// Find the plane to be used in the order
   bPlaneFound := false;
  // Run a SQL query to find planes that can do the trip
  qrySQL.SQL.Text := 'Select * from tblPlanes where [Max Load] >= ' + FloatToStr(pOrderWeight) + ' and [Max Distance] >= ' + FloatToStr(pDistance) + ' and Retired = False'+' Order By [Max Load]' ; // Get all planes that can do this trip and sort them from the smallest size to the largest based on the max load that they can carry. The plane must also not be retired
  qrySQL.Open ;

   if not qrySQL.IsEmpty then  // Checks that the field (Query) does not come up empty
   begin // If results are returned form the query
      qrySQL.First ;

      // Calculate the DropOfftime
      rHoursTripLength := pDistance / qrySQL['Cruising Speed']  ;
      dtDropOffDateTime := pPickupDateTime + (rHoursTripLength)/ 24 ;   // Also convert it hours to days

      while not qrySQL.eof and (bPlaneFound = false) do   // Go thru the query results to check plane availibily
      begin
         tblOrders.First ;
         bValid := True;
        { iPlaneCount := qrySQL['Count'] ;   // Set the amount of planes that Volitant Express has of that plane type}
         while not tblOrders.Eof and (bValid = true) do
         begin
            if tblOrders['PlaneID'] = qrySQL['PlaneID'] then
            begin
              if (((HoursBetween(tblOrders['Pickup Date'],  dtDropOffDateTime )) > 24) or ((HoursBetween(pPickupDateTime , tblOrders['E/D Date'])) > 24 )) or (tblOrders['Status'] = 'Canceled') then  // The new orders DropOff dateTime must me more that 24 hours before the Existing orfders Pickup date AND the new orders Pickup date must be more than 24 hours after the existing orders Drop OFf Date and the Existing order must not have been cancelled
              begin
                 // Just leave like this, valid plane
              end
              else
              begin // Else, if the New ORders DateTimes does not fit in this range for the current plane, move on to the next plane in the list of the SQL query
                 bValid := False ;
              end;

            end;

          tblOrders.Next ;
         end;

         if bValid = True then // if the active plain in the SQL query has an open slot in that time frame
         begin
           bPlaneFound := True ;// Return the planeID to be used in the order
           Result := qrySQL['PlaneID'] ;
         end;

        qrySQL.Next ;
      end;

      if bPlaneFound = False then  // If no available plane is found, return a -1
      Result := -1;
   end
   else
   Result := 0 ; // Return a 0 of no plain that can do the trip is found

end;

procedure TfrmVolitant_Express.FormActivate(Sender: TObject);
var
  tFile : TextFile ;
  sLine, sKeep : string ;
  iPos : integer ;
  I, k: Integer;
  rKeep : real;
begin
// Form Acticvate
iCountryCount := 0 ;
iID := 0 ;
// Set the admin company controll buttons
btnDeleteCompanyAdmin.Enabled := False;
chkSuspendAccount.Enabled := False;
 btnUpdateSuspension.Enabled := False;

// array population

    // Populate the arrays containing the countries info
    if not FileExists('Country_Coordinates.txt')  then
    begin
      ShowMessage('Country_Coordinates.txt was not found!  Create a new Country_Coordinates.txt file that does not have more than 245 countries and has the format of CountryCode#Latitude#Longitude#CountryName');
      Exit;
    end
    else
    begin
      AssignFile(tFile, 'Country_Coordinates.txt')  ;
      Reset(tFile);

      while not Eof(tFile) and (iCountryCount < 245)  do
      begin
        Inc(iCountryCount);
        Readln(tFile, sLine) ;
         //arrCountryCode
        iPos := Pos('#', Sline);
        arrCountryCode[iCountryCount] := Copy(sLine, 1, iPos-1 ) ;
        Delete(sLine, 1 , iPos);
         //arrLatitude
         iPos := Pos('#', Sline);
        arrlatitude[iCountryCount] := (StrToFloat(Copy(sLine, 1, iPos-1 )) * (pi/ 180)) ;
        Delete(sLine, 1 , iPos);
        //arrLongitude
         iPos := Pos('#', Sline);
        arrLongitude[iCountryCount] := (strToFloat(Copy(sLine, 1, iPos-1 )) * (pi/ 180)) ;
        Delete(sLine, 1 , iPos);
        //CountryName
        arrCountryName[iCountryCount] := sLine ;

      // ShowMessage(IntToStr(iCountryCount) );
      end;

      CloseFile(tFile) ;
    end;

    // Sort the country arrays alpabetically from A to Z
    for I := 1 to iCountryCount -1 do
      for k := I+1 to iCountryCount do
      begin
        if UpperCase(arrCountryName[k]) < UpperCase(arrCountryName[i])   then
        begin
          // arrCountryName
          sKeep := arrCountryName[I];
          arrCountryName[I] := arrCountryName[k] ;
          arrCountryName[k] := skeep;
          // arrCountryCode
           sKeep := arrCountryCode[I];
          arrCountryCode[I] := arrCountryCode[k] ;
          arrCountryCode[k] := skeep;
          // arrLongitude
          rKeep := arrLongitude[I];
          arrLongitude[I] := arrLongitude[k];
          arrLongitude[k] := rKeep;
          //arrLatitude
          rKeep := arrLatitude[i];
          arrLatitude[i] := arrLatitude[k];
          arrLatitude[k] := rKeep;

        end;
      end;

    // Load the countries into selection boxes
    cmbCountryBased.Clear ; // Clears any txt that may have been in the comboBox
    for I := 1 to iCountryCount do
    cmbCountryBased.Items.Add(arrCountryName[i]) ;

    // Special character array
      iSpecialCharacterCount := 0;
    
     if not FileExists('Special_Characters.txt')  then
      begin
        ShowMessage('Special_characters.txt not found. Create a new one with no more than 32 characters') ;
        Exit ;
      end
      else
      begin
        AssignFile(tFile, 'Special_Characters.txt');
        Reset(tFile) ;

        while not Eof(tFile) and (iSpecialCharacterCount < 32) do
        begin
           Inc(iSpecialCharacterCount); 

           Readln(tFile, arrSpecialCharacters[iSpecialCharacterCount] ) ;
        end;
       
        CloseFile(tFile) ;
      end;

  if bTimer = false then // Only set this on the first time the activation code runs
  begin

  // Run the plane animation
  imgPlaneAnimation.Stretch := True;
  imgPlaneAnimation.Picture.LoadFromFile('Program Media/airplane-side-view-travel-passenger-commercial-vector-15881171.jpg') ;
  imgPlaneAnimation.Left := 0 ;

  {       // This is code from my grade 10 PAT
    ProgressValue := 0;
  ProgressBarStartUp.Min := 0;
  ProgressBarStartUp.Max := 1000;
  ProgressBarStartUp.Position := ProgressValue;   }

  // Set the timers properties
  tFlightAnimation.Interval := 250; // 1000 milliseconds (1 second)
  tFlightAnimation.Enabled := True;
    //  Countdown := 5  ;

  bTimer := true ;
  end;

// Database Connection

  conDB.Connected := False ;
  conDB.LoginPrompt := False ;
  conDB.ConnectionString := 'Provider=Microsoft.Jet.OLEDB.4.0;Data Source=Volitant_Express_db.mdb;Mode=ReadWrite;Persist Security Info=False' ;
  conDB.Open;
  // SQL Query connection
  qrySQL.Connection := conDB ;
  dsrSQL.DataSet := qrySQL ;
  dbgSQL_admin.DataSource := dsrSQL ;

  // Grid Query Connection
  qryGrid.Connection := conDB ;
  dsrGrid.DataSet := qryGrid;
  dbgGridDisplay.DataSource := dsrGrid ; // Link to the dbg grid

  // tblCompany    DO this for every table
  tblCompany.Connection := conDB ;
  tblCompany.TableName := 'tblCompany';
  tblCompany.Active := True;
  dsrCompany.DataSet := tblCompany ;
 //tblOrders
  tblOrders.Connection := conDB ;
  tblOrders.TableName := 'tblOrders';
  tblOrders.Active := True;
  dsrOrders.DataSet := tblOrders ;
  // tblItems
  tblItems.Connection := conDB ;
  tblItems.TableName := 'tblItems';
  tblItems.Active := True;
  dsrItems.DataSet := tblItems ;
  // tblPlanes
  tblPlanes.Connection := conDB ;
  tblPlanes.TableName := 'tblPlanes';
  tblPlanes.Active := True;
  dsrPlanes.DataSet := tblPlanes ;
  // tblAdmins
  tblAdmins.Connection := conDB ;
  tblAdmins.TableName := 'tblAdmins';
  tblAdmins.Active := True;
  dsrAdmins.DataSet := tblAdmins ;
  dbgAdmins.DataSource := dsrAdmins ; // Set the admins dbgGrid to display the admins table
end;

procedure TfrmVolitant_Express.FormCreate(Sender: TObject);
CONST Width_Devide = 5.22;
       Height_Devide = 6.51;
var
  tFile : textfile;
  sColor : string ;
begin
  // Set the program to open  on the middle of the screen. depending on screen resolution
  frmVolitant_Express.Left := Round(Screen.Width /2) - Round(frmVolitant_Express.Width / 2) ;
  frmVolitant_Express.Top :=  Round(Screen.HEight / 2) - Round(frmVolitant_Express.Height / 2)  ;

// Set up the tab sheets
{
tsRegister.TabVisible := False;
tsLogin.TabVisible := False;
tsIntroVideo.TabVisible := False;
tsGallery.TabVisible := False;
}
      {                              // Dont add the sum page to list, will cause errors due to activepage.tabvisible
  tsItemsAdmin.TabVisible := False;
  tsPlanesAdmin.TabVisible := False;
  tsOrdersAdmin.TabVisible := False;
  tsCompaniesAdmin.TabVisible := False;
  tsEmailsAdmin.TabVisible := False;
  tsCustomAdmin.TabVisible := False;
               }

  tsContact.TabVisible := False;
  tsLastInfo.TabVisible := False;
  tsRegConfirm.TabVisible := False;

  // Set sonme starting variablles
  bTimer := False;
  iImageCount := 0;

  // Set the programs color themes
    // Set the forms color
    if FileExists('Themes/formtheme.txt')  then  // Only load if the file exists else just leave as normal
    begin
      AssignFile(tFile, 'Themes/formtheme.txt');
      Reset(tFile);
      Readln(tFile, sColor);    // Read the color code from the txt file
      frmVolitant_Express.Color := StrToInt(sColor);  // Set the color of the form
      CloseFile(tFile);    // Close the file
    end;
    // Set the color of the welcome label
    if FileExists('Themes/welcome_label_theme.txt')  then  // Only load if the file exists else just leave as normal
    begin
      AssignFile(tFile, 'Themes/welcome_label_theme.txt');
      Reset(tFile);
      Readln(tFile, sColor);    // Read the color code from the txt file
      lblWelcome.font.Color := StrToInt(sColor);  // Set the color of the label
      CloseFile(tFile);    // Close the file
    end;
    // Set the color of the home label
    if FileExists('Themes/home_label_theme.txt')  then  // Only load if the file exists else just leave as normal
    begin
      AssignFile(tFile, 'Themes/home_label_theme.txt');
      Reset(tFile);
      Readln(tFile, sColor);    // Read the color code from the txt file
      lblWelcomeHome.font.Color := StrToInt(sColor);  // Set the color of the label
      CloseFile(tFile);    // Close the file
    end;
    // Set the color of the home group box
    if FileExists('Themes/home_grb_theme.txt')  then  // Only load if the file exists else just leave as normal
    begin
      AssignFile(tFile, 'Themes/home_grb_theme.txt');
      Reset(tFile);
      Readln(tFile, sColor);    // Read the color code from the txt file
      grbHome.Color := StrToInt(sColor);  // Set the color of the group box
      CloseFile(tFile);    // Close the file
    end;
    // Set the color of the Login label
    if FileExists('Themes/Login_label_theme.txt')  then
    begin
      AssignFile(tFile, 'Themes/Login_label_theme.txt');
      Reset(tFile) ;
      Readln(tFile, sColor) ;
      lblLogin.Font.Color := StrToInt(sColor);
      CloseFile(tFile);
    end;
    // Set the color theme of the Orders Label
    if FileExists('Themes/Order_label_theme.txt')  then
    begin
      AssignFile(tFile, 'Themes/Order_label_theme.txt');
      Reset(tFile) ;
      Readln(tFile, sColor);
      lblOrder.Font.Color := StrToInt(sColor);
      CloseFile(tFile);
    end;
end;

procedure TfrmVolitant_Express.FormResize(Sender: TObject);
begin
// Set the height and width of the program whenever a change is being tried to made to it. this prevents the program from being resized
frmVolitant_Express.Height :=  687;
frmVolitant_Express.Width :=       1250;
end;

function TfrmVolitant_Express.GetPlainCruisingSpeed(pPlaneID: integer): real;
var
  bPlaneFound : boolean ;
begin
// Get the cruising speed for a plane
  tblPlanes.First ;
  bPlaneFound := False ;
  while not tblPlanes.Eof and not (bPlaneFound) do   // Search for the plane matching the ID
  begin
    if tblPlanes['PlaneID'] = pPlaneID  then // If a matching plane is found
    begin
      bPlaneFound := True ;
      Result := tblPlanes['Cruising Speed'];
    end;
    tblPlanes.Next ;
  end;
  // Incase, for some reason, a plane is not found
  if not bPlaneFound then
  Result := 550 ;
end;



procedure TfrmVolitant_Express.imgDynamicOnclick;
var
  sString : string;
begin
// Onclick for the dynamic images. Display something positive stat wise about volitant express

  case RandomRange(1,6)  of      // When an image is clicked, a random message with stats wil be displayed
  1: begin     // Count how many successfull orders has taken place
      qrySQL.SQL.Text := 'Select Count(*) as Result from tblOrders where status = "Delivered"';
      qrySQL.open;
       sString := (inttostr(qrySQL['Result']))  ;
       ShowMessage('Total successfull orders: '+sString) ;
    end;
    
  2: begin  // Count how many active planes the company have
       qrySQL.SQL.Text := 'Select Count(*) as Result from tblPlanes where Retired = NO';
      qrySQL.open;
       sString := (inttostr(qrySQL['Result']))  ;
       ShowMessage('Total Active Planes: ' + sString ) ; 
    end;
  3:     
    begin // Count how many items are currently shipped by Volitant Express
       qrySQL.SQL.Text := 'Select Count(*) as Result from tblItems where Retired = NO';
      qrySQL.open;
       sString := (inttostr(qrySQL['Result']))  ;
       ShowMessage('We currently transport '+ sString + ' different items') ;
    end;
  4:
    begin // Count how many companies are customers
         qrySQL.SQL.Text := 'Select Count(*) as Result from tblCompany';
      qrySQL.open;
       sString := (inttostr(qrySQL['Result']))  ;
       ShowMessage(sString +' companies trust us to transport their goods from locations around the world') ;
    end;
  5:
    begin  // Display the country with the most Companies as customers of Volitant Express
        qrySQL.SQL.Text := 'Select TOP 1 [Location Based] as Result from tblCompany Group By [Location Based] ORDER BY COUNT(*) DESC';
      qrySQL.open;
       sString := ((qrySQL['Result']))  ;
       ShowMessage('Most of our Customer Companies are based in: '+ sString ) ;
    end;
  end;

end;

procedure TfrmVolitant_Express.lstManagePlaneClick(Sender: TObject);
var
  iPlaneID : integer ;
  bFound : boolean ;
begin
// Load file info into the components
  // Validate that an item is selected
    if lstManagePlane.ItemIndex = -1 then
    begin
      ShowMessage('Select a valid plane');
      exit;
    end;
    // Get the ID
  iPlaneID  := StrToInt(Copy(lstManagePlane.Items[lstManagePlane.ItemIndex], 1, Pos('-',lstManagePlane.Items[lstManagePlane.ItemIndex])-1 ) ) ;
   // Get the matching record
   tblPlanes.First ;
   bFound := False;
   while not tblPlanes.Eof and (bFound = False) do
   begin
      if tblPlanes['PlaneID'] = iPlaneID then // If a matching record was found
      begin
        bFound := True;
        sedUpdateFuelRands.Value := Trunc(tblPlanes['FuelCost']) ; // Set the Rands
        sedUpdateFuelCents.Value := Round(Frac(tblPlanes['FuelCost'])* 100 ) ; // Set the cents
        chkRetirePlane.Checked := tblPlanes['Retired'] ; // If the plane is retired or not
       { sedUpdatePlaneCount.Value := tblPlanes['Count'] ; }
      end;
   tblPlanes.Next ;
   end;

end;

procedure TfrmVolitant_Express.lstPaymentClick(Sender: TObject);
var
  iOrderID : integer;
  sLine : string;
  borderFound : boolean ;
begin
// When an item is clicked on to pay the order, then show a messgae of the time range of the order
     //Validation
    // Ensure that a valid order to pay is selected
    if lstPayment.ItemIndex = -1 then
    begin
      ShowMessage('Please Select a valid Order to pay') ;
      exit ;
    end;
    // get the order ID
    slIne := lstPayment.Items[lstPayment.ItemIndex] ;
    Delete(sLine, 1, Pos(':', sLine) ) ;
    iOrderID := StrToInt(Copy(sLine, 1 ,Pos(' --Item:', sLIne)-1) )   ;
      // Search for the ID
      tblOrders.First ;
      borderFound := False ;
      while not tblOrders.Eof and (bOrderFound = False) do
      begin
        if tblOrders['OrderID'] = iOrderID then  // If a matching ID is found
        begin
          borderFound := True ;
          ShowMessage('Pickup Date: ' + DateTimeToStr(tblOrders['Pickup Date']) +  #13+ 'Drop Off Date:' + DateTimeToStr(tblOrders['E/D Date'])) ;
        end;
        tblOrders.Next ;
      end;
end;

procedure TfrmVolitant_Express.lstSelectItemManageClick(Sender: TObject);
var
  sItemName : string;
  bFound : boolean;
begin
// Update the Update components
       // Ensure that item was selected to update
  if lstSelectItemManage.ItemIndex = -1 then
  begin
    ShowMessage('Select item that exists') ;
    exit ;
  end;
  // Item Name extraction
  sItemName := Copy(lstSelectItemManage.Items[lstSelectItemManage.ItemIndex], 1, POS(' -- ', lstSelectItemManage.Items[lstSelectItemManage.ItemIndex])-1)   ;
  redUpdateItem.Clear ;
  // Search the item to update
  bFound := False;
  tblItems.First ;
  while not tblItems.eof and (bFound = False) do
  begin
    if sItemName = tblItems['Item Name'] then
    begin
      bFound := True;
      iItemUpdateID := tblItems['ItemID'] ; // Get the record of the item selected
      // Update the components for the update of the ITEM

      redUpdateItem.Lines.Add(tblItems['Note']);
      // Item retirement
      if tblItems['Retired'] = True then
      btnRetireItem.Caption := 'UnRetire Item'
      else
       btnRetireItem.Caption := 'Retire Item';

      chkChangeItemDangerous.Checked := tblItems['Dangerous'];    // Set the dangerous component

        // Calculate the cost
        sedUpdateItemRands.Value := Trunc(tblItems['T_Cost/kg']);
        sedUpdateItemCents.Value := Round(Frac(tblItems['T_Cost/kg'])*100);
    end;
    tblItems.Next ;
  end;
end;

procedure TfrmVolitant_Express.lstSelectOrderAdminClick(Sender: TObject);
var
  I: Integer;
  bOrderFound, bItemFound, bPlaneFound : boolean;
  sInfo : string ;
begin
// Onlick for orders to be managed by admin
  // validation
  // Ensure than an order was selected
  if lstSelectOrderAdmin.ItemIndex = -1 then
  begin
    ShowMessage('Please select a valid order to manage')  ;
    exit;
  end;

  // When clicking on an order in the lst box= Show a message that gives more info about the order
  tblOrders.First ;
  bOrderFound := False;
  while not tblOrders.Eof and not (bOrderFound) do
  begin
    if tblOrders['OrderID']= strtoint(Copy(lstSelectOrderAdmin.Items[lstSelectOrderAdmin.ItemIndex], 1, Pos('--', lstSelectOrderAdmin.Items[lstSelectOrderAdmin.ItemIndex])-1))  then
    begin
      bOrderFound := True ;
        // Load the current status of the order into radiogroup where it can be changed
        for I := 0 to 4 do
        begin
          if rgpOrderStatus.Items[i] = tblOrders['Status']  then  // If the status that matches was found
          rgpOrderStatus.ItemIndex := I;
        end;
        // Load the componets to update the date info
        dpUpdatePickupDate.Date := DateOf(tblOrders['Pickup Date']);
        tpUpdatePickupTime.Time := TimeOf(tblOrders['Pickup Date']) ;
        // Show more info of the order
        sInfo := 'Order Info:' +#13+
        'Weight: ' + FloatToStr(tblOrders['Weight']) + ' kg' + #13+
                'Order Placed Date: ' + DateToStr(tblOrders['Order Date']) + #13+
                'Pickup Country: ' + tblOrders['Pickup Country'] + #13+
                'Drop of Country: ' + tblOrders['Drop of Country'] + #13+
                'Pickup Date: ' + DateTimeToStr(tblOrders['Pickup Date']) +#13+
                'Estimated Drop of Date: ' + DateTimeToStr(tblOrders['E/D Date'])+ #13+
                'Distance: ' + FloatToStr(tblOrders['Distance']) + ' km' + #13;
          // Get if the order has been paid
          if tblOrders['Paid'] then
          sInfo := sInfo + 'Paid: YES'  + #13
          else
          sInfo := sInfo + 'PAID: NO' +#13;
          // Get the item being used in the order
          bItemFound := False;
          tblItems.First ;
          while not tblItems.eof and (bItemFound = FAlse)do    // Search for a matching item
          begin
            if tblItems['ItemID'] = tblOrders['ItemID'] then  // if a matching item was found
            begin
              bItemFound := True ;
              sInfo := sInfo + 'Item: ' + tblItems['Item Name'] + #13;
            end;
            tblItems.Next ;
          end;
          // Get the plane being used in the order
          bPlaneFound := False;
          tblPlanes.First ;
          while not tblPlanes.Eof and (bPlaneFound = False) do    // Search for a matching plane
          begin
            if tblPlanes['PlaneID'] = tblOrders['PlaneID'] then     // If a matching plane was found
            begin
              bPlaneFound := True ;
              sInfo := sInfo + 'Plane: '+ tblPlanes['Plane Name']+ #13;
            end;
            tblPlanes.Next ;
          end;
    end;
    tblOrders.Next ;
  end;
  ShowMessage(sInfo) ;
end;

procedure TfrmVolitant_Express.lstSelectTransportItemClick(Sender: TObject);
var
  bItemFound : boolean;
  sDangerous : string ;
begin
// When an item is clicked
  // validate than an item is selected
  if lstSelectTransportItem.ItemIndex = -1  then
  begin
    ShowMessage('Select valid item to transport!');
    exit ;
  end;
  // Display a showmessage to display more info about item. Find the item selected
  tblItems.First ;
  bItemFound := False;
  while not tblItems.Eof and (bItemFound = False) do
  begin
    if tblItems['Item Name'] = lstSelectTransportItem.Items[lstSelectTransportItem.ItemIndex] then  // If a matching item is found
    begin
      bItemFound := True;
      // Get if the item is Dangerous
      if tblItems['Dangerous'] = True then
      sDangerous := 'Dangerous: YES'
      else
      sDangerous := 'Dangerous: NO';
      ShowMessage('Category: '+tblItems['Category'] + #13+ 'Cost/kg: ' + FloatToStrF(tblItems['T_Cost/kg'], ffCurrency , 10,2) + #13+ sDangerous + #13+ 'Note: '+ tblItems['Note'] );
    end;
    tblItems.Next ;
  end;

end;

procedure TfrmVolitant_Express.pgcAdminChange(Sender: TObject);
begin
// Change things on the tabpages when a change is made
redCompanyOut.Clear ;
end;

function TfrmVolitant_Express.Prevent_Duplication: string;
Const ROWS = 11;     // Must be odd
      COLLUMS = 41;  // Must be odd. Ceil(Collums/2) number must be >= Rows
var
  I, k, X, Y: Integer;
  sString : string;
  arrPrevent : array[1..ROWS , 1..COLLUMS] of char;     // 2D array
  bRight, bTriange : boolean;
begin
// Creates a string to add to a richedit for example to help make it more difficult to fakely duplicate
  sString := '' ;
  bRight := True ;
  X:= Ceil(COLLUMS / 2);
  Y := Ceil(COLLUMS / 2);
  if X >= ROWS then // Ensure that Rows to Collums ratio if fine for triange generation
  bTriange := True
  else
  bTriange  := False ;

    // Add the snakes code
  for I := 1 to ROWS do  // Repeat this process 7 times
  begin
     for k := 1 to COLLUMS do
     begin
        if Odd(I)  then
        begin // Run this code if the row number is odd
              arrPrevent[I, K] := '=';
        end
        else
        begin      // Run code if line number is even
          arrPrevent[i, k] := inttostr(RandomRange(1, 10) )[1];
        end;
     end;
     // add the triangle only of Rows to Collums ratio is fine
     if bTriange then
     begin
     arrPrevent[I, X]  := '%'  ;
      arrPrevent[I, Y]  :=  '%' ;
      X:= X - 1;
      Y := Y +1  ;
     end;
      if not Odd(i) then  // Only run this on even lines
          if bRight = True then   // Add line on the right side
           begin
             bRight := False ;
              arrPrevent[I, COLLUMS] := '|';
           end
           else if bRight = False then
           begin // add line on the left side
              bRight := True;
             arrPrevent[I, 1] := '|';
           end;
  end;
    // Create string for output
  for I := 1 to Rows do
  begin
    for k := 1 to COLLUMS  do
    begin
      sString := sString + arrPrevent[I, K] ;
    end;

    sString := sString + #13;
  end;
  Result := sString ;
end;

procedure TfrmVolitant_Express.rgpOrderStatusClick(Sender: TObject);
begin
// Warn that set to delivered / Cancelled can not be undone; Cancelled will refund money. This is on the admin update order page
if (rgpOrderStatus.Items[rgpOrderStatus.ItemIndex] = 'Delivered') or (rgpOrderStatus.Items[rgpOrderStatus.ItemIndex] = 'Canceled') then
ShowMessage('WARNING!!'+ #13+ 'If the order is set to Delivered or Canceled, no updates will be posible to the order in the future.'+#13+'A canceled order will refund any paid money');
end;

procedure TfrmVolitant_Express.sedEnterCNameSearchOrderUpdateChange(
  Sender: TObject);
begin
// Clear the edt and sed for searching for a company or OrderID, as ID will be valued above C Name
edtCompanyNameSearchOrders.Clear;
sedSearchByOrderID.Value := 0 ;
end;

procedure TfrmVolitant_Express.sedEnterCompanyIDChange(Sender: TObject);
begin
// Set things right when a change is made ragarding the companies management
  btnDeleteCompanyAdmin.Enabled := False;
  chkSuspendAccount.Enabled := False;
  btnUpdateSuspension.Enabled := False;
  btnLoadCompany.Enabled := True;
end;

procedure TfrmVolitant_Express.sedSearchByOrderIDChange(Sender: TObject);
begin
// Clear the Company name edit and the companyID search spinedit to used OrderID to search for order with that ID
edtCompanyNameSearchOrders.Clear ;
sedEnterCNameSearchOrderUpdate.Value := 0 ;
end;

procedure TfrmVolitant_Express.SendEmail(pEmailAddress, pMessage: string);
var // Setup a few variables 
 SMTP: TIdSMTP;
  Msg: TIdMessage;
  SSL: TIdSSLIOHandlerSocketOpenSSL;
  sMyEMailAddress : string ;
begin
// Send the email to a single user function
    SMTP := TIdSMTP.Create(nil);
  Msg := TIdMessage.Create(nil);
  SSL := TIdSSLIOHandlerSocketOpenSSL.Create(nil);
  sMyEMailAddress := 'vrobert997@yahoo.com';
  try
    // Setup SSL
    SSL.SSLOptions.Method := sslvTLSv1_2;
    SSL.SSLOptions.Mode := sslmUnassigned;
    SSL.SSLOptions.VerifyMode := [];
    SSL.SSLOptions.VerifyDepth := 0;

    // Assign SSL handler to SMTP, basically, i log into yahoo's email service
    SMTP.IOHandler := SSL;
    SMTP.UseTLS := utUseImplicitTLS; // For port 465
    SMTP.Host := 'smtp.mail.yahoo.com';
    SMTP.Port := 465;
    SMTP.Username := sMyEMailAddress; // The email address the emails will be send from
    SMTP.Password := 'jenanqebkhkwpqi';    // Yahoo app-specific password

    // Create the email to be send to the user
    Msg.Clear;
    Msg.From.Address := sMyEMailAddress; // This is the email address that the user will see the email coming from
    Msg.Recipients.EmailAddresses := pEmailAddress ; // This is the users accounts email address
    Msg.Subject := 'EMAIL From VOLITANT EXPRESS';
    Msg.Body.Text := pMessage;

    // Send it, this will attempt to actually send the email to the users email address
    SMTP.Connect;
    try
      SMTP.Send(Msg);
    finally
      SMTP.Disconnect;
    end;
    // Confirmation message that email was send successfully
    ShowMessage('Email sent successfully!');
  except
    on E: Exception do
      ShowMessage('Failed to send email: ' + E.Message);
  end;

  // Clean up
  SSL.Free;
  SMTP.Free;
  Msg.Free;

  ShowMessage('');
end;

procedure TfrmVolitant_Express.SetOrderStatusItemIndex(pStatus: string);
var
  I: Integer;
begin
  for I := 0 to 4 do
  begin
    if rgpOrderStatus.Items[i] = pStatus then
    rgpOrderStatus.ItemIndex := i ;
  end;
end;

procedure TfrmVolitant_Express.tFlightAnimationTimer(Sender: TObject);
begin
 // Timer code
 // Change the image location
 imgPlaneAnimation.Left := imgPlaneAnimation.Left + 30; // Move it more to the left

 if imgPlaneAnimation.Left > 1100 then // If the image reaches to the right, reset it to the left
 imgPlaneAnimation.Left := 0 ;
end;

function TfrmVolitant_Express.ValidateEmail(pEmail: string): Boolean;
var
  sEmail : string ; 
  I, iPointPos, iATcount : integer ;
  bPoint: boolean;
begin
// Function to validatate an email address
// Returns a true in the end if the email is valid
   sEmail := pEmail;
    // Checks that an email was entered
  if (sEmail = '') or (sEmail = ' ') then
  begin
    ShowMessage('Please enter an email address');
    Result := False;
    exit;
  end;
  // Checks that the email is in a certain range 
  if Length(sEmail) > 70  then
  begin
    ShowMessage('Email must be 70 characters or shorter') ;
      Result := False;
    Exit;
  end;

     // ensures that the email does not start with a dot
    if sEmail[1] = '.' then
    begin
      ShowMessage('Email may not start with a .');
        Result := False;
      exit; 
    end;
    
    // Checks that there are no spaces in the email
  if Pos(' ', sEmail) > 0  then
  begin
    ShowMessage('No spaces are allowed in the email');
      Result := False;
    exit; 
  end;
  
  iATcount := 0;
    // Check that the email contains valid characters
  for I := 1 to Length(sEmail)  do
    begin
      if not (sEmail[I] in ['A'..'Z', 'a'..'z', '@', '.', '0'..'9']) then
      begin
        ShowMessage('Invalid characters in email');
          Result := False;
        exit; 
      end;
      if sEmail[i] = '@' then
      Inc(iATcount)  ;
    end;

  // Checks that there is an @ in the email
  if not (iATcount  = 1) then
  begin
    ShowMessage('Email must have 1 @ only');
      Result := False;
    exit; 
  end;

  // Checks that there is a . after the @ in the email
  bPoint := False ;
  iPointPos := 0;
   for I := Length(sEmail)  Downto Pos('@', sEmail)  do
   begin
      if sEmail[i]= '.' then
      begin
        bPoint := True ;
        iPointPos := I ;
     //   Break;
      end;
   end;
     
   if bPoint = False then
   begin
     ShowMessage('Enter a valid domain after the @ (.)')  ;
       Result := False;
     Exit ;
   end
   else
   begin
      if ( (iPointPos = Length(sEmail) )) then // ensures that the last character is not a dot
      begin
        ShowMessage('Enter a valid domain after the @');
          Result := False;
        exit;
      end;
      // ensures that there is something after a dot 
      if not (sEmail[iPointPos+1] in ['A'..'Z', 'a'..'z']) then
      begin
          ShowMessage('Enter a valid domain after the @ ()');
            Result := False;
        exit;
      end;
      
      for I := 1 to Length(sEmail)-1  do
        begin
          if ((sEmail[I] = '.') and (sEmail[I+1] = '.')) then // Checks that there are not double dots in the email
          begin
            ShowMessage('No double dots allowed in email');
              Result := False;
            exit;
          end;
          // ensures that there is not a . directly agaist the @ in the email
          if ((sEmail[I] = '.') and (sEmail[I+1] = '@')) or ((sEmail[I] = '@') and (sEmail[I+1] = '.')) then
          begin
            ShowMessage('Enter a valid email. There must be things between the dot and the @');
              Result := False;
            exit;
          end;
          
        end;
   end;
    Result := True;
end;

procedure TfrmVolitant_Express.WriteToFormTheme(pFileName: string;
  pColorValue: integer);
  var
    tFile : textfile;
begin
// Write to the Files containing the themes
  // Always rewrite the file as a new value will always be stored
  AssignFile(tFile, pFileName) ;
  Rewrite(tFile) ;

  Writeln(tFile, pColorValue) ;
  CloseFile(tFile) ;
end;

end.
// THE END OF THE FILE :)